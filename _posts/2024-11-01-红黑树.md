---
title: 红黑树
date: 2024-11-01 18:49:20 +0800
categories: [算法,数据结构]
tags: [aogorithm]     
---
# 红黑树
## 简介
红黑树是一棵特殊的二叉搜索树。红黑树中每个结点要么是红色要么是黑色，而且约束了不同颜色结点的分布规则，利用这些约束规则可以实现用相对小的代价来实现二叉搜索树的相对平衡。所谓相对平衡指的是从任意结点出发到其一个叶子结点的简单路径长度不可能超过到另一个叶子结点路径长度的2倍。其对失衡的容忍度比AVL自平衡二叉树要高因而能够降低再平衡操作频率以减少开销。
## 红黑树的哨兵结点（NIL）
红黑树的每个结点包含5个属性：key,color,left,right和parent。二叉树中某个节点如果没有子结点或父结点则其对应字段的值为Null。而在红黑树中为了便于处理构建了一个哨兵节点其color=black其他字段可以为任意值用来代替上述的Null引用。哨兵结点也称为外部结点，包含key值的结点为内部结点。
## 红黑树规则
1. 每个结点要么黑色要么红色
2. 根结点为黑色
3. 叶子（哨兵结点NIL）结点为黑色
4. 如果一个结点是红色的，则它的两个结点都是黑色的（意味着从根结点到叶子结点的任意简单路径上不会出现连续两个红色）
5. 从任意结点出发到所有叶子结点路径上的黑色结点数量相等
## 红黑树规则分析
1. 通过上面规则不难看出从根结点到叶子结点的路径只有一种情况下红色节点数量最多，即每个黑色结点后面都跟一个红色。即形如：黑-(红-黑) x N。很明显红色结点最多的情形下依然比黑色结点少。可见从根结点出发到叶子结点的每条路径上红色均不会比黑色多（考虑路径长度不包括出发结点），这样就能保证当两条路径上黑色结点数量相同时一条路径不会比另一条路径长超过2倍，也就实现了相对平衡（近似平衡）。上面分析是从根节点出发，如果换成任意节点比如从某个红色(黑色)结点出发也能得出相同结论。
## 红黑树的高度
> 一棵有n个结点的红黑树高度至多为2lg(n+1)

证明思路：
1. 通过上面的分析可知从根结点出发任意路径上红结点数量不可能超过黑结点数量，因此树高不会大于2倍的黑高。由此得到树高h和黑高bh的关系:h<=2bh
2. 那么如果此时我们知道黑高和结点数量的关系，即需要知道n个结点的红黑树黑高的最大值即可得出最终结论
3. 由于红色节点不增加黑高，那么要使得黑高最高则红色结点数量应该尽可能的少。比如全部节点都是黑色结点。
4. 我们首先假设n个节点全部作为黑色节点时恰好能满足红黑树性质的情况。此时一棵完全由黑色结点构成的红黑树事实上是一个完美二叉树，其高度和黑高均为lg(n+1)，且n=2^x -1（x为某个正整数）。
5. 所以此时树高最高值为2lg(n+1)
6. 那么如果n的取值使得无法找到一个正整数x以满足n=2^x -1公式时的情况又是什么样呢？
7. 假设距离n最近的两个值a和b均满足2^x -1（x为某个正整数）的情况且a < n < b
8.  可知结点数量为a时黑高最高值和结点数量为b时黑高最高值相差1
9.  随着节点数量由b向a方向减少黑高最高值势必减少，也即n个结点的黑高等于a个结点对应的黑高均为lg(a+1)
10. 由于a < n,且lg(a+1)为单调递增函数则有n个结点黑高最大肯定不超过lg(n+1)
11. 综上树高最高值不超过2lg(n+1)

## 红黑树插入or删除结点复杂度
插入or删除节点对应时间复杂度均为O(lg(n))，操作过程不需要借助额外的变量因此空间复杂度为O(1)

## java中红黑树的应用
1. Java的TreeMap基于红黑树实现。使用时注意要么在构造器中提供比较器要么key必须实现Comparable接口，否则抛出异常：...cannot be cast to java.lang.Comparable
2. TreeSet基于TreeMap实现
3. HashMap默认结构是一个链表数组。搜索时通过hash元素可以确定待查找元素在数组中下标的位置，然后遍历该位置处的链表以查找目标数据。极端情况下当链表长度过长时HashMap性能会严重下降。于是jdk1.8开始如果插入数据或扩容过程中发现链表的长度过长（超过TREEIFY_THRESHOLD = 8）且数组长度不小于MIN_TREEIFY_CAPACITY = 64时将超长的链表转换成一颗红黑树以提高性能。

## 红黑树和B树或B+树的区别
B树一个结点包含的数据量较大，而且子结点数量一般也远大于2。通常情况下根据磁盘页大小来限制结点可保存数据的多少以尽量保证一个结点的所有数据和键恰好占用磁盘上的一页大小。这样访问每个节点只需要一次磁盘io。由于每个结点可以有数量较多的子结点因此整棵树的高度会远低于红黑树，此时在主内存中只保留根节点的情况下需要更少的磁盘io即可访问到目标数据。所以核心区别是树高明显更低，大规模数据处理时可以只加载部分数据到内存，后续操作io次数较少。如果数据量不大或者内存空间富裕的话肯定红黑树性能更高。
B+树是B树的一种变体，所有数据都在叶子节点，内部节点只存储键用于导航到叶子结点因此导致内部节点能存储更多的键，子结点也会更多，树高也更矮，磁盘io此时更小，而且叶子结点之间还用指针串联起来以方便范围查询。可见B+树天生就适合用来存储文件系统或数据库的索引。目前现代关系型数据库最广泛的支持索引结构就是 B+ 树。