---
title: IM即时聊天系统设计方案（一）
date: 2024-12-11 10:30:00 +0800
categories: [技术方案设计]
tags: [技术方案,IM] 
---

## 设计目标
- 聊天形式：单聊、群聊
- 会话管理：置顶、隐藏（客户端不可见，有新消息时恢复可见）
- 聊天内容：多消息类型支持
- 性能保障：消息不丢失、不乱序、尽量及时到达

## 数据库设计

**注意：所有表均需要逻辑删除标识、创建人、创建时间、更新人、更新时间字段，为了精简文章长度下文不再专门列出。**

1. 用户表：t_user
   
   | column    | type         | desc      |
   | --------- | ------------ | --------- |
   | user_id   | bigint       | PK,用户id |
   | nick_name | varchar(100) | 用户昵称  |
   | icon      | varchar(100) | 用户头像  |

2. 会话基本信息表：t_session
   
   | column            | type         | desc                                        |
   | ----------------- | ------------ | ------------------------------------------- |
   | session_id        | bigint       | PK                                          |
   | session_type      | tinyint      | 0:单聊 1:群聊                               |
   | participant_count | int          | 会话参与者人数，单聊为1，群聊为群内实际人数 |
   | last_msg_id       | bigint       | 最后一条消息id                              |
   | total_msg_count   | int          | 群聊消息总数                                |
   | title             | varchar(100) | 会话标题，单聊会话此字段为空                |
   | icon              | varchar(100) | 会话头像/图标，单聊会话此字段为空           |
   | session_version   | int          | 会话基本信息主版本号                        |

   

3. 会话参与者视图表（每个会话参与者视角下的会话状态数据）：t_session_view
   
   | column           | type         | desc                                                                                                   |
   | ---------------- | ------------ | ------------------------------------------------------------------------------------------------------ |
   | user_id          | bigint       | PK, 会话所有者用户id.                                                                                  |
   | session_id       | bigint       | 一个会话内的所有参与者通过相同的session_id进行关联                                                     |
   | last_read_msg_id | tinyint      | 最后一条已读消息id                                                                                     |
   | unread_count     | int          | 为便于查询冗余未读数信息，极端情况可造成会话未读数不准。查看会话详情时未读数会强制置零以实现自动修复。 |
   | view_version     | int          | 版本号，表数据更新时用来实现乐观锁。同时用来检查客户端和后端数据是否一致                               |
   | title            | varchar(100) | 会话标题，单聊会话从此字段取值。群聊会话从基本信息表取值                                               |
   | icon             | varchar(100) | 会话头像/图标                                                                                          |
   | session_status   | unsigned int | 最高位代表是否置顶显示，次高位代表是否显示                                                             |
   
   联合索引：user_id、session_status（desc）、last_msg_id(desc)

4. 会话参与者关系表
   
   | column              | type   | desc                 |
   | ------------------- | ------ | -------------------- |
   | session_id          | bigint | PK,会话表 session_id |
   | participant_user_id | bigint | 会话参与者用户id     |

5. 聊天记录表：t_session_message
   
   | column      | type         | desc                                                                     |
   | ----------- | ------------ | ------------------------------------------------------------------------ |
   | message_id  | bigint       | PK,消息id。同一会话内保持自增                                            |
   | session_id  | bigint       | 会话id                                                                   |
   | sender_id   | bigint       | 发送者用户id                                                             |
   | status      | int          | 0:normal 1:已撤回                                                        |
   | version     | int          | 默认为0，当消息内容变更时版本号自动加一                                  |
   | msg_typ     | int          | 0:文本消息、1：图片、2：语音、3：文件、...                               |
   | msg_content | varchar(255) | 消息内容，不同消息类型结构可能存在差异。前端需要根据不同消息类型分别处理 |

## 整体通信方案设计

整体采用推拉结合方式进行数据交换。消息下发、事件通知（会话版本更新、消息版本更新等）采用推送方式进行。客户端发送消息、主动获取后端会话数据、聊天记录数据时通过http接口进行拉取。

## 用户数据版本管理机制

当客户端有能力对会话数据进行持久化时可以通过比对版本号来确定用户本地数据是否需要更新以期降低服务端查询压力。

- 用户版本号（本文也称用户大版本）：使用IM功能的每个用户维护一个全局版本号。其任意一个会话数据发生变动将导致该全局版本号增大。该全局版本号不必持久化，可用redis缓存进行管理。用户每次登陆系统时对该版本号续期7天，超过7天未登录该用户大版本缓存自动过期。当用户登录时检查本地大版本和服务端大版本号是否一致，如果一致则表名用户离线期间没有新的会话/聊天事件产生。如果不一致或者服务端用户大版本缓存丢失则从后端拉取所有会话的版本号和本地进行对比。
- 会话版本号：会话版本号包括会话基本信息主版本号（t_session.session_version）和会话参与者视图版本号(t_session_view.view_version)两部分组成。任何一部分发生变动即意味着该用户下该条会话需要更新。会话版本号的变动将导致用户版本号变动。

## 发送消息过程
![发送消息过程](/assets/images/im/IM-sendMsg.jpg)

## 用户登录状态管理
1. 用户通过http接口进行登录信息验证，验证成功后后端响应一个登录凭据AUTH_TOKEN(后端拿用户userId+凭据过期时间通过加密算法得到一个字符串)。
2. 用户和服务端建立长链接后首先将上述AUTH_TOKEN发送到后端进行验证，验证通过后服务端在redis中使用hash类型来记录用户在线状态：

   ```
    {userId} -> { "connectServer": "192.168.1.3"}
   ```
3. 同时在建立连接的服务端本地通过hashmap来记录用户id和channel的关联关系
4. 当用户连接断开后删除上述用户在线状态redis缓存和本地缓存

## 消息推送路由规则
1. 需要推送消息时从redis缓存中拿到当前用户连接的服务端ip
2. 调用指定ip的服务端进行实际消息推送
3. 当服务端接受到推送请求后再次检查本地是否存在对应channel，存在则进行发送。不存在时则通过消息队列广播方式让所有服务端尝试进行消息推送

## 消息推送过程
上面发送消息过程仅大概介绍了从客户端发送消息到消息持久化直至触发推送的过程。具体推送逻辑见下图：
![IM-push](/assets/images/im/IM-push.jpg)

## 消息可靠性保证
1. 从上面消息推送过程可以看到消息是按照顺序进行发送的，确认收到前一条才会推送下一条。如果因网络原因服务端未收到确认，在用户在有新消息可被接收时会重新触发推送。如果用户长时间没有新消息可被接收，等到下次用户重新建立连接时会将本地记录的版本号和后端进行比对，此时数据不一致的会话会进行更新。
2. 客户端每次打开会话详情页面时检查会话数据中的last_msg_id在本地是否存在，如果不存在则说明本地聊天消息数据不全，本地可尝试从last_msg_id开始向后端分页拉取聊天消息记录。

## 消息顺序性保证
1. 后端使用队列按照顺序推送
2. 消息id在会话级别内自增，前端需要确保消息按照id顺序排列。

## 消息实时性保证
1. 用户消息添加待发送进队列时同时添加一条用户补偿消息延时任务。该任务1分钟后会再次检查队列是否存在待发送数据，如果存在则触发消息发送并再次添加补偿任务直至队列为空或用户下线。