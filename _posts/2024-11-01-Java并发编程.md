---
title: Java并发编程
date: 2024-11-01 20:30:00 +0800
categories: [Java开发, 并发编程]
tags: [java,concurrency]     
---




## ThreadLocal原理

- Thread 拥有实例属性threadLocals。对threadLocal进行读取时是访问的每个线程自己的threadLocals属性。因此可以保证线程安全。
    
    ```java
    package java.lang;
    
    public class Thread implements Runnable {
        // ...
    
        /* ThreadLocal values pertaining to this thread. This map is maintained
         * by the ThreadLocal class. */
        ThreadLocal.ThreadLocalMap threadLocals = null;
        
        // ...
    }
    ```
    
- ThreadLocalMap是一个特殊的HashMap（特殊在两方面。1：entry的弱引用实现 2：使用**线性探测法**来处理哈希冲突），其`Entry` 类通过弱引用来关联`ThreadLocal` 对象。弱引用关联的对象在 GC 时如果没有其他强引用会被回收掉。
    
    ```java
    public class ThreadLocal{
    		// ... 
    		static class ThreadLocalMap {
            
            static class Entry extends WeakReference<ThreadLocal<?>> {
                /** The value associated with this ThreadLocal. */
                Object value;
    
                Entry(ThreadLocal<?> k, Object v) {
                    super(k);
                    value = v;
                }
            }
            // ...
    		}
    		// ...
    }
    ```
    
- 如果该 `ThreadLocal` 失去了其他强引用关系，那么gc时由于Entry的是通过弱引用来关联key，将对导致该弱引用所关联的ThreadLocal对象被回收。调用Entry::get方法实际上是调用WebReference::get方法以获取其关联的对象，当被关联的ThreadLocal对象被回收时调用此方法将返回null。
- 从Entry到ThreadLocal的引用是弱引用，但是ThreadLocalMap到Entry的引用确是强引用。因此当ThreadLocal被回收时Entry还存活对象，只是调用其get方法已经获取不到其所引用的ThreadLocal了。此时Entry对象事实上已经是没必要继续存活的了。因此会导致内存泄露。
- 为了处理这种情况，`ThreadLocalMap` 实现了一个惰性清理机制：
    - 在 `get`、`set`、`remove` 等操作中会主动检查 `ThreadLocalMap` 中是否存在键为 `null` 的 `Entry`。注意这里不会检查所有的失效entry，仅检查被操作key临近的部分元素。
    - 如果存在这样的条目，`ThreadLocalMap` 会在访问时清理这些“无效”的条目，确保不会长时间占用内存。
    - 因此这种措施可以缓解内存泄露的危害
- 但是如果ThreadLocal的强引用关系一直存在，比如ThreadLocal是一个单例bean的成员属性或者是静态属性。将无法通过弱引用的方式自动释放不再使用的ThreadLocal。
- 因此为了避免ThreadLocal发生内存泄露一定记得手动调用remove方法。在使用线程池时也可以对ThreadPoolExecutor进行扩展在afterExecute方法里对线程池所涉及的所有ThreadLocal进行手动remove操作


## 同步技术

### 内置锁synchronized

- 内置锁是可重入的

### `java.util.concurrent`包同步工具类：

- CountDownLatch: `CountDownLatch` 由一个整数计数器（`count`）构成，该计数器初始化时指定一个数值，然后每当一个线程完成任务时，可以调用 `countDown()` 方法将计数器减 1。当计数器的值降到 0 时，所有等待在 `await()` 上的线程会被唤醒并继续执行
- 信号量 Semaphore 用来控制同时访问某个资源的操作数量。信号量管理着一定数量的许可，使用者需要先通过acquire方法获取许可，操作完成后通过release方法释放许可。同时能acquire成功的数量由信号量的构造函数参数指定。如果所有许可已经被申请则acquire方法会被阻塞。（Dubbo支持通过信号量的方式来控制并发）
- 栅栏（CyclicBarrier）：栅栏用来协调指定数量的线程在栅栏位置进行等待（集合）直到所有指定数量的线程全部到达栅栏位置后允许所有线程继续执行。每个线程调用CyclicBarrier::await()方法,此方法讲导致现场阻塞直至所有线程都到达栅栏位置。当所有线程到达栅栏位置后改栅栏被重置，可重复使用

### 显式锁

- ReentrantLock  支持公平、非公平模式。支持尝试获取锁、指定时间内尝试获取锁已经获取锁时可以允许被其他线程打断，以避免长时间阻塞或死锁。其余和Synchronized一样都是实现了可重入的标准互斥锁。
- 读写锁ReentrantReadWriteLock ： 多个线程可以同时持有读锁，但写锁是独占的，即同一时刻只能有一个线程持有写锁。同样可以选择公平或非公平策略；

### CAS操作与原子类

## 内存可见性volatile关键字

volatile的两个作用。1个是保证了内存的可见性，另一个是禁止重排序（参考下面happens-before规则）

## Java内存模型

### 主内存与工作内存

- Java内存模型规定所有变量(实例属性、静态属性和构成数组对象的元素，不包括局部变量。因为局部变量都是线程私有的不涉及共享)都存储在主内存中（主内存是java虚拟机内存的一部分）。
- 每个线程有自己的工作内存，线程执行过程中用到的主内存的变量都会在线程自己的工作内存中存储一份主内存的副本
- 线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存的数据
- 不同线程之间无法访问对方工作线程内的变量，线程之间的变量值的传递必须通过主内存进行

![image.png](/assets/images/java-concurrency/image.png)

### happens-before规则

> happens-before规则里的关键术语“先行发生于（happens-before）”的意思是一个事件先行发生会对后面的的事件可见或发生作用。例如在一个线程内首先将变量a设置为1，则后续通过代码即可观察到变量a=1（对应下面第一条规则：程序次第原则）。
> 

> 同时，如果a事件先行发生于b事件，则a之前的所有事件对b之后的事件可见。
> 
1. 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。
2. 管程锁定规则：一个unlock操作先行发生于随后对同一把锁的lock操作。例如：一个同步代码块a线程先获取了锁进行执行，执行完毕后释放锁之后又有b线程获取了这个相同的锁开始执行，此时b线程可以观察到a线程unlock操作之前的所有行为所造成的影响（比如：a线程在同步块内更新了某个共享变量的值，b线程进入同步块后即可获取到a线程更新后的值。而如果b线程没有获取同一把锁或者没有通过同步的方式访问该共享变量则a线程前面更新的结果可能对b不可见）
3. volatile变量规则：对一个volatile变量的写先生发生于后续对其的读
4. 线程启动规则：Thread的start()方法先行发生于后续此线程中的每一个操作
5. 线程终止规则：线程A结束执行并且随后被线程B检测到线程A已终止（通过Thread::join()或Thread::isAlive()）则线程A中的所有操作都对线程B可见。
6. 线程中断规则：对线程interrupt()的调用先行发生于该线程内部对interrupted状态的感知（通过Thread::interrupted()）
7. 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
8. 传递性：A happens-before B & B happens-before B 可以得到A happens-before C