---
title: 线程和线程池
date: 2025-12-01 20:30:00 +0800
categories: [Java开发, 并发编程]
tags: [java,concurrency]     
---

# Java线程介绍

## Java线程Thread的实现

Java 中的线程通常是映射到操作系统的本地线程（也称为内核线程），每个 Java 线程都直接对应一个操作系统线程。

### Java线程生命周期（状态转换）

Java线程的6种状态(state)：

- **New**: 创建线程对象后尚未启动的线程
- **Runnable**：启动后处于运行中或等待获取cpu时间片的状态。对应于操作系统线程状态：running和ready
- **Waiting**：无限期等待中，此时需要等待被其他线程显示唤醒。（Object::wait()、Thread::join()、LockSupport::park()方法触发线程进入Waiting）
- **Timed Waiting**: 有限期等待，处于此状态的线程在timeout时间后会被自动唤醒。以下方法会让线程进入限期等待状态：
    - Thread::sleep()
    - 设置了timeout参数的Object::wait()
    - 设置了timeout参数的Thread::join()
    - LockSupport::parkNanos()
    - LockSupport::parkUntil()
    - 
    
    [Java线程中断方法：Object::wait()、Thread::sleep()、LockSupport::park()](https://www.notion.so/Java-Object-wait-Thread-sleep-LockSupport-park-13476ee6a8be80e1ad95dea403b07ae4?pvs=21)
    
- **Blocked**：阻塞状态。线程处于阻塞状态的原因是在等待获取一个排它锁。
- **Terminated**：已终止状态

## Java虚拟线程技术

从JAVA21开始正式支持虚拟线程技术。

### java虚拟线程原理和特点

- 虚拟线程是由 JVM 管理的轻量级用户线程，不与 OS 线程一一对应。

- 虚拟线程运行时会挂载到可用的载体线程（platform thread）上执行，当遇到阻塞操作（如 I/O、sleep）时会自动卸载，阻塞期间不会占用 OS 线程。阻塞结束后虚拟线程可重新挂载到载体线程继续执行。

- 虚拟线程的栈帧保存在堆上，可快速恢复执行。

### java虚拟线程的优势or适用场景

- 创建和上下文切换开销极低（用户态切换，无内核调度），可以支持百万级并发。

- 不需要线程池管理，每个任务可以直接创建虚拟线程。

- 特别适合 I/O 密集型 或 阻塞操作多 的高并发服务端场景。

- CPU 密集型任务不适合虚拟线程，可能带来额外管理开销。

- 对涉及有限资源的任务（数据库、第三方服务接口）仍需控制并发，例如使用信号量限制同时执行的虚拟线程数量。

## Java线程池技术

### ThreadPoolExecutor

#### 向ThreadPoolExecutor提交任务流程：

1. 线程数小于核心线程数时尝试直接创建新核心线程执行任务
2. 将任务插入队列
3. 队列已满，尝试增加线程（非核心）来执行任务
4. 线程数已达最大，执行拒绝策略

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
        * Proceed in 3 steps:
        *
        * 1. If fewer than corePoolSize threads are running, try to
        * start a new thread with the given command as its first
        * task.  The call to addWorker atomically checks runState and
        * workerCount, and so prevents false alarms that would add
        * threads when it shouldn't, by returning false.
        *
        * 2. If a task can be successfully queued, then we still need
        * to double-check whether we should have added a thread
        * (because existing ones died since last checking) or that
        * the pool shut down since entry into this method. So we
        * recheck state and if necessary roll back the enqueuing if
        * stopped, or start a new thread if there are none.
        *
        * 3. If we cannot queue task, then we try to add a new
        * thread.  If it fails, we know we are shut down or saturated
        * and so reject the task.
        */
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
```

#### ThreadPoolExecutor拒绝策略：

- AbortPolicy 默认：抛出异常
- DiscardPolicy 丢弃任务
- DiscardOldest 丢弃存在时间最久的任务
- CallerRunsPolicy 提交任务线程自己执行

#### ThreadPoolExecutor关闭过程
##### shutdown()
1. 修改线程池状态为：SHUTDOWN。此状态下线程池不再接受新任务提交。
2. 依次调用所有空闲线程（worker执行任务过程会加锁，shutdown时通过是否能加锁成功来判断是否空闲）的interrupt方法，线程池队列中有任务时不影响线程继续获取并处理剩余任务。当队列中的任务被处理完后interrupt的线程通过take()阻塞操作获取任务时会被打断进而退出执行。
3. 线程池最终进入TERMINATED状态
```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        //修改线程池状态为：SHUTDOWN。不再接受新任务提交。
        advanceRunState(SHUTDOWN);
        //依次调用所有空闲线程interrupt方法
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    //尝试将线程池置为TERMINATED状态
    tryTerminate();
}
```
##### shutdownNow()
1. 修改线程池状态为：STOP。不再接受新任务提交。
2. 所有工作线程上均触发调用interrupt方法，注意：对于正在执行的任务如果没有响应interrupt或者吞掉了interruptException、或者根本没有阻塞点那么当前任务将被执行完成（除非java进程被强制杀死）
3. 清空任务队列
4. 尝试设置状态为TERMINATED
5. 返回队列中未被执行的任务

#### ThreadPoolExecutor非核心线程在什么情况下回收
当非核心线程设置超时时间后，线程将通过带超时时间的poll方法从队列取任务。如果超时未取得任务将导致当前线程被回收。

#### ThreadPoolExecutor预启动核心线程方法
- 调用prestartAllCoreThreads()方法将会保证所有核心线程被立即创建。
- 调用prestartCoreThread()方法一次最多创建一个核心线程

#### ThreadPoolExecutor动态修改核心线程方法
通过setCorePoolSize(int corePoolSize)方法可动态调整核心线程数

### 设置线程池大小

**经验公式**

- cpu密集型任务：cpu核心数+1
- io密集型任务：cpu核心数 * （1 + 平均IO等待时间/CPU计算时间）

实际应用过程中的注意事项：

- 如果执行并发任务的服务同时在提供线上服务，则应该避免导致cpu使用率过高
- 如果涉及大内存操作则应注意并发线程数下内存使用量是否过大进而导致频繁gc或服务器内存不足
- 实际应用中可以通过测试评估资源占用，生产环境运行时可以从保守参数开始进行调整（java线程池支持动态调整核心线程数ThreadPoolExecutor::setCorePoolSize()）。

### ForkJoinPool

1. Fork/Join 模型
    
    Fork/Join 模型是一种并行计算模型，主要有以下几个步骤：
    
    - **分解（Fork）**：将一个大任务分解成多个小任务。每个小任务可以独立地进行处理。
    - **执行**：这些小任务可以并行执行，这通常是通过 `ForkJoinPool` 来完成的。
    - **合并（Join）**：当所有小任务完成后，合并它们的结果以形成最终结果。
2. ForkJoinPool 的结构
    
    `ForkJoinPool` 的核心组成部分是 **工作窃取算法**，它支持任务的高效并行处理，具体特点包括：
    
    - **工作窃取**：每个工作线程都有一个双端队列，用于存放它所处理的任务。如果某个线程完成了自己的任务，它可以尝试从其他工作线程的队列中窃取任务。这种机制能够更均匀地分配任务，减少线程空闲的情况。
    - **线程数量**：`ForkJoinPool` 通常使用可用的处理器核心数来设置线程的数量，默认线程数量为 `Runtime.getRuntime().availableProcessors()`。
3. 使用 ForkJoinPool
    
    使用 `ForkJoinPool` 通常涉及以下几个步骤：
    
    1. **定义任务**：创建一个继承自 `RecursiveTask<V>` 或 `RecursiveAction` 的任务类。`RecursiveTask<V>` 适合有返回值的任务，而 `RecursiveAction` 适合没有返回值的任务。
    2. **实现分解和合并逻辑**：在任务类中实现 `compute()` 方法，定义如何分解任务和如何合并结果。
    3. **执行任务**：使用 `ForkJoinPool` 的实例来执行任务。

4. 示例代码

    以下是一个用 `ForkJoinPool` 的示例，计算给定数字范围内的和：
    
    ```java

    import java.util.concurrent.RecursiveTask;
    import java.util.concurrent.ForkJoinPool;

    class SumTask extends RecursiveTask<Long> {
        private final long start;
        private final long end;

        public SumTask(long start, long end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected Long compute() {
            if (end - start <= 10) { // 基线条件
                long sum = 0;
                for (long i = start; i <= end; i++) {
                    sum += i;
                }
                return sum;
            } else {
                long mid = (start + end) / 2;
                SumTask leftTask = new SumTask(start, mid);
                SumTask rightTask = new SumTask(mid + 1, end);

                leftTask.fork(); // 异步执行左侧任务
                long rightResult = rightTask.compute(); // 同步执行右侧任务
                long leftResult = leftTask.join(); // 等待左侧任务完成并获取结果

                return leftResult + rightResult; // 合并结果
            }
        }
    }

    public class ForkJoinPoolExample {
        public static void main(String[] args) {
            ForkJoinPool pool = new ForkJoinPool();
            SumTask task = new SumTask(1, 100);
            long result = pool.invoke(task); // 提交任务并等待结果
            System.out.println("Sum: " + result);
        }
    }

    ```

5. 主要特性
    - **适合大任务**：`ForkJoinPool` 特别适合处理大规模、可分解的任务，最大限度地利用多核处理器的性能。
    - ForkJoinTask的join方法在等待依赖的task完成处理之前当前work线程不会阻塞会继续执行其他任务
6. 注意事项
    - **任务粒度**：选择合适的任务粒度至关重要。如果任务过小，频繁的任务分解和合并会增加开销，反而影响性能。
    - **资源竞争**：由于多个线程同时访问共享资源，可能会出现资源竞争和锁的问题，需要谨慎处理。

[Java多线程进阶（四三）—— J.U.C之executors框架：Fork/Join框架（1） 原理](https://segmentfault.com/a/1190000016781127)
