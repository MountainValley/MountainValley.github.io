---
title: Redis典型问题Q&A
date: 2024-11-01 20:30:00 +0800
categories: [nosql, redis]
tags: [redis,nosql]     
---

# Redis典型问题Q&A

## 单线程的Redis为什么快
1. 执行单个命令块
   1. 数据存储和查询在内存中进行，无需等待磁盘i/o。
   2. Redis内部使用hash表结构将所有键值对存储到Key Space(键空间)中，写入、删除和查询的时间复杂度趋近O(1)
2. 并发响应快
   1. Redis 使用 I/O 多路复用技术，通过非阻塞的方式监控多个连接的 I/O 状态，减少阻塞在未就绪的连接上。这样能够在单线程中高效处理多个客户端连接的 I/O 操作。
   2. 单线程避免了上下文切换带来的性能消耗。当然使用单线程模式必须基于单个操作速度够快的基础之上，如果单个命令执行时间过长则不如使用多线程已减少等待命令执行完成前的耗时。

## Redis常用数据类型及其应用场景

| 类型                   | 应用场景                                                                                                                                                                       | 特殊说明                                                                                                                                                               |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| String                 | 1.最常规的get/set操作，value可以是String，也可以是数字，且支持二进制位操作。2.通过bitmap相关操作可以实现数据记录统计功能，比如用来记录签到、活跃信息。也可以用来实现布隆过滤器 | A value can't be bigger than 512 MB                                                                                                                                    |
| Hash                   | 常用作结构化的对象存储                                                                                                                                                         | 1. New in Redis Community Edition 7.4 is the ability to specify an expiration time or a time-to-live (TTL) value for individual hash fields. 2. key和value只能是string |
| List                   | 双端队列，可以作为queue或stack。可以通过LINDEX命令来访问指定位置元素而不删除                                                                                                   | 元素只能是string                                                                                                                                                       |
| Set                    | 缓存不重复的集合数据，可以支持各种集合运算                                                                                                                                     | 元素只能是string                                                                                                                                                       |
| Sorted set             | 缓存集合数据时可以指定元素分值，并支持按照分值排序和查询。可用来实现排行榜、范围查询、延时队列                                                                                 | 元素只能是string                                                                                                                                                       |
| Geospatial（地理位置） | 支持存储地理坐标的特殊数据结构，基于有序集合。支持对地理位置数据进行范围查询、距离计算等操作。                                                                                 |                                                                                                                                                                        |


## Redis中Sorted Set的数据结构
- 默认配置下当某个元素长度超过64k或元素个数超过128个时使用跳表作为底层数据结构，跳表同时存储底层链表和多级索引数据。查找数据时从最上层索引开始依次向底层进行搜索。由于每层索引数量是更低一层元素数量的一半，因此搜索过程类似于在二叉树上进行搜索，其时间复杂度为O(logn)
  ![Redis SkipList](/assets/images/redis/Redis%20SkipList.png)
- 当元素个数少于128且没有任何一个元素长度超过64时为了减少空间占用进保存原始数据链表（压缩列表）。搜索数据时间复杂度为O(logn)

## Redis为什么使用跳表来实现Sorted Set而不是红黑树
- 跳表是用概率算法来计算元素应该添加到的索引层级，从第一层开始命中概率逐级降低25%以保证整个索引树结构概率性平衡。而且底层存储实际数据的双向链表是有序的可以方便支持范围查询，比较贴合Sorted Set使用场景。
- 红黑树的平衡性是通过严格的约束条件实现的。（即从任意节点开始到其每个后代叶子节点路径上的黑节点数量相同。且不能有连续红节点。因此可以保证从任意节点开始到各个叶子节点的路径长度之间相差不好超过1倍。）因此节点的插入和删除操作相比于跳表消耗更高，但是好在平衡性是稳定的。而跳表虽然是大概率稳定的但不是强保证，特别是当节点数量较多时可能没有红黑树那么稳定。而且红黑树上每个节点存储实际数据和红黑属性，跳表的话除了最底层存储所有元素之外索引层也几乎存储了同样数量的节点因此额外的空间消耗也是o(n)
- 综上小数据量时可以使用跳表，稍大数据量且追求稳定情况下使用红黑树。如果数据量打到内存放不下则考虑使用B+树将数据写入磁盘。

## 什么是缓存穿透&如何避免
缓存穿透是指大量查询根本不存在的数据，这些请求既不会命中缓存，也不会在数据库中找到。由于缓存无法处理这些请求，所有查询都会绕过缓存直接访问数据库，进而导致数据库的负载骤增。

解决方案：
1. 首先服务应该提供限流、降级或熔断策略避免造成故障扩大，尽量避免db和底层服务崩溃情况出现。
2. 系统应具备一定的爬虫识别和屏蔽
3. 对db中不存在的数据同样设置缓存并设置一个有效期，比如1分钟。（该方案比较轻量，但是只针对会重复请求的情况有效而且会造成短时间内生成较多缓存数据，谨慎使用）
4. 如果是应对大量针对相同key的缓存穿透可以限制访问底层数据库并发数，确保只有少量线程直接通过数据库获取数据（如果数据不存在则设置不存在缓存）。大量线程等待缓存更新。
5. 如果请求key是随机无法预测的可设置布隆过滤器，可以使用redisson、redis插件、guava提供的布隆过滤器实现（较复杂），此方案要求根据全部db数据实时维护bitmap数据。
6. 数据量不大时可以增加一层本地缓存。
   


## 什么是缓存雪崩&如何避免
缓存雪崩是指在同一时间大量的缓存数据过期，导致大量请求直接涌入数据库，瞬间增加数据库的压力，甚至可能导致数据库崩溃。

解决方案：
1. 基于缓存的查询服务在查询db时可以限制并发，同时提供限流、降级或熔断设置，避免造成故障扩大，尽量避免db和底层服务崩溃情况出现。
2. 过期时间增加随机值避免大量缓存或对db压力较大的多个缓存同时过期
3. 合理设置redis持久化机制避免reids重启导致大量缓存丢失，比如可以同时启用RDB+AOF两种持久化机制或启用混合持久化。
4. redis设置主从复制，自动故障转移机制避免redis不可用


## 缓存场景下Redis和DB双写如何保证数据一致性
原因分析：

核心原因是双写过程缺乏事务保护。因此可能存在部分成功（A：原子性被破坏）、双写过程出现并发导致出现脏数据(I:隔离性被破坏)、不一致情况发生即代表一致性被破坏（C：一致性）、reids主从切换可能导致的持久性被破坏（D：持久性）

由于redis自身对数据一致性的有限保证（redis无法保证数据完全不会丢失）导致无法100%解决双写一致性问题，而只能通过合理设计双写方案以尽量避免不一致情况的发生，同时提供最终一致性保证。

双写方案：
- 所有缓存数据均需要设置合理的过期时间以实现最终一致性保证。这个措施是最低限度保证，当业务对数据一致性容忍程度较高时可只进行此条设置。
- 数据写入顺序应该首先写入DB然后删除缓存key。
- 为了避免删除缓存key后随即被其他线程因为查询动作从从库中获取到过时数据并用来设置缓存的情况发生，可以设置延时双删，即写入db后首先删除key然后可通过延时队列方式在一定时间后再次触发删除操作以避免数据库主从延迟导致缓存已过时数据。延迟双删同时也可以应对不同线程并发双写的情况。



## Redis 键值对过期策略
1. redis使用定期删除+惰性删除策略（惰性删除:查询时判断是否过期，如过期则删除并返回空）
2. 主从复制模式下从库对过期键的完全删除依赖于主库，且不会进行惰性删除。因此主从复制模式下直接访问从库可能获取到已过期数据。

## Redis 内存淘汰机制
在redis.conf中，有一行配置：
```
maxmemory-policy volatile-lru
```
该配置的值包括：
- noeviction：默认设置。当内存不足时，新写入会报错；
- allkeys-lru：当内存不足时，移除最近最少使用的key
- allkeys-lfu：当内存不足时，移除最少使用的key
- allkeys-random：当内存不足时，随机移除某个key
- volatile-lru：当内存不足时，在设置了过期时间的keys中，移除最近最少使用的key；
- volatile-lfu：当内存不足时，在设置了过期时间的keys中，移除最少使用的key；
- volatile-random：当内存不足时，在设置了过期时间的keys中，随机移除某个key
- volatile-ttl：当内存不足时，在设置了过期时间的keys中，移除有更早过期时间的key

如何选择：
- 缓存使用：如果 Redis 主要用作缓存，推荐使用 allkeys-lru 或 allkeys-lfu 策略来确保热点数据保留在内存中，并清理较少使用的数据。
- 数据持久化：如果需要保存的重要数据不应该被淘汰，则可以通过 noeviction 策略避免数据丢失，同时根据应用需求手动控制内存使用情况

## Redis使用注意事项
1. 一般而言redis主要应用场景是作为缓存使用，如果需要将其作为db使用来记录一段时间范围内的数据需要在开发团队内就redis使用场景达成一致意见，并确认当前redis的内存淘汰机制以避免数据。
2. 主从复制模式下从库对过期键的完全删除依赖于主库，且不会进行惰性删除。因此主从复制模式下直接访问从库可能获取到已过期数据。因此一般建议只在主库上进行读写，如果需要进行水平扩展可以考虑使用redis集群服务将redis集群划分为多个master-slaver组，每组内的master只负责处理一部分哈希槽的数据
3. 集群模式下redis只有第0号数据库可以使用