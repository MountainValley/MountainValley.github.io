---
title: Redis典型问题Q&A
date: 2024-11-01 20:30:00 +0800
categories: [nosql, redis]
tags: [redis,nosql]     
---

# Redis典型问题Q&A

## 单线程的Redis为什么快
1. 执行单个命令块
   1. 数据存储和查询在内存中进行，无需等待磁盘i/o。
   2. Redis内部使用hash表结构将所有键值对存储到Key Space(键空间)中，写入、删除和查询的时间复杂度趋近O(1)
2. 并发响应快
   1. Redis 使用 I/O 多路复用技术，通过非阻塞的方式监控多个连接的 I/O 状态，减少阻塞在未就绪的连接上。这样能够在单线程中高效处理多个客户端连接的 I/O 操作。
   2. 单线程避免了上下文切换带来的性能消耗。当然使用单线程模式必须基于单个操作速度够快的基础之上，如果单个命令执行时间过长则不如使用多线程已减少等待命令执行完成前的耗时。

## Redis常用数据类型及其应用场景
| 类型       | 应用场景                                                                                                                                                   | 特殊说明                                                                                                                                                               |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| String     | 1.最常规的get/set操作，value可以是String，也可以是数字；2.通过bitmap相关操作可以实现数据记录统计功能，比如用来记录签到、活跃信息。也可以用来实现布隆过滤器 | A value can't be bigger than 512 MB                                                                                                                                    |
| Hash       | 常用作结构化的对象存储                                                                                                                                     | 1. New in Redis Community Edition 7.4 is the ability to specify an expiration time or a time-to-live (TTL) value for individual hash fields. 2. key和value只能是string |
| List       | 双端队列，可以作为queue或stack                                                                                                                             | 元素只能是string                                                                                                                                                       |
| Set        | 缓存不重复的集合数据，可以支持各种集合运算                                                                                                                 | 元素只能是string                                                                                                                                                       |
| Sorted set | 缓存集合数据时可以指定元素分值，并支持按照分值排序和查询。可用来实现排行榜、范围查询、延时队列                                                             | 元素只能是string                                                                                                                                                       |

## 什么是缓存穿透&如何避免
缓存穿透是指大量查询根本不存在的数据，这些请求既不会命中缓存，也不会在数据库中找到。由于缓存无法处理这些请求，所有查询都会绕过缓存直接访问数据库，进而导致数据库的负载骤增。

解决方案：
1. 首先服务应该提供限流、降级或熔断策略避免造成故障扩大，尽量避免db和底层服务崩溃情况出现。
2. 系统应具备一定的爬虫识别和屏蔽
3. 对容易发生穿透风险的api可设置布隆过滤器，可以使用redisson、redis插件、guava提供的布隆过滤器实现（较复杂），此方案要求根据全部db数据实时维护bitmap数据。
4. 对db中不存在的数据同样设置缓存并设置一个有效期，比如1分钟。（该方案比较轻量，但是只针对会重复请求的情况有效而且会造成短时间内生成较多缓存数据，谨慎使用）
   


## 什么是缓存雪崩&如何避免
缓存雪崩是指在同一时间大量的缓存数据过期，导致大量请求直接涌入数据库，瞬间增加数据库的压力，甚至可能导致数据库崩溃。

解决方案：
1. 基于缓存的查询服务在查询db时可以限制并发，同时提供限流、降级或熔断设置，避免造成故障扩大，尽量避免db和底层服务崩溃情况出现。
2. 过期时间增加随机值避免大量缓存或对db压力较大的多个缓存同时过期
3. 合理设置redis持久化机制避免reids重启导致大量缓存丢失，比如可以同时启用RDB+AOF两种持久化机制或启用混合持久化。
4. redis设置主从复制，自动故障转移机制避免redis不可用


## 缓存场景下Redis和DB双写如何保证数据一致性
原因分析：

核心原因是双写过程缺乏事务保护。因此可能存在部分成功（A：原子性被破坏）、双写过程出现并发导致出现脏数据(I:隔离性被破坏)、不一致情况发生即代表一致性被破坏（C：一致性）、reids主从切换可能导致的持久性被破坏（D：持久性）

由于redis自身对数据一致性的有限保证（redis无法保证数据完全不会丢失）导致无法100%解决双写一致性问题，而只能通过合理设计双写方案以尽量避免不一致情况的发生，同时提供最终一致性保证。

双写方案：
- 所有缓存数据均需要设置合理的过期时间以实现最终一致性保证。这个措施是最低限度保证，当业务对数据一致性容忍程度较高时可只进行此条设置。
- 数据写入顺序应该首先写入DB然后删除缓存key。
- 为了避免删除缓存key后随即被其他线程因为查询动作从从库中获取到过时数据并用来设置缓存的情况发生，可以设置延时双删，即写入db后首先删除key然后可通过延时队列方式在一定时间后再次触发删除操作以避免数据库主从延迟导致缓存已过时数据。延迟双删同时也可以应对不同线程并发双写的情况。



## Redis 键值对过期策略
1. redis使用定期删除+惰性删除策略（惰性删除:查询时判断是否过期，如过期则删除并返回空）
2. 主从复制模式下从库对过期键的完全删除依赖于主库，且不会进行惰性删除。因此主从复制模式下直接访问从库可能获取到已过期数据。

## Redis 内存淘汰机制
在redis.conf中，有一行配置：
```
maxmemory-policy volatile-lru
```
该配置的值包括：
- noeviction：默认设置。当内存不足时，新写入会报错；
- allkeys-lru：当内存不足时，移除最近最少使用的key
- allkeys-lfu：当内存不足时，移除最少使用的key
- allkeys-random：当内存不足时，随机移除某个key
- volatile-lru：当内存不足时，在设置了过期时间的keys中，移除最近最少使用的key；
- volatile-lfu：当内存不足时，在设置了过期时间的keys中，移除最少使用的key；
- volatile-random：当内存不足时，在设置了过期时间的keys中，随机移除某个key
- volatile-ttl：当内存不足时，在设置了过期时间的keys中，移除有更早过期时间的key

如何选择：
- 缓存使用：如果 Redis 主要用作缓存，推荐使用 allkeys-lru 或 allkeys-lfu 策略来确保热点数据保留在内存中，并清理较少使用的数据。
- 数据持久化：如果需要保存的重要数据不应该被淘汰，则可以通过 noeviction 策略避免数据丢失，同时根据应用需求手动控制内存使用情况

## Redis使用注意事项
1. 一般而言redis主要应用场景是作为缓存使用，如果需要将其作为db使用来记录一段时间范围内的数据需要在开发团队内就redis使用场景达成一致意见，并确认当前redis的内存淘汰机制以避免数据。
2. 主从复制模式下从库对过期键的完全删除依赖于主库，且不会进行惰性删除。因此主从复制模式下直接访问从库可能获取到已过期数据。因此一般建议只在主库上进行读写，如果需要进行水平扩展可以考虑使用redis集群服务将redis集群划分为多个master-slaver组，每组内的master只负责处理一部分哈希槽的数据
3. 集群模式下redis只有第0号数据库可以使用