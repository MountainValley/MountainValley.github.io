---
title: 选择、冒泡和插入排序
date: 2024-11-01 18:49:20 +0800
categories: [算法,排序]
tags: [aogorithm]     
---
# $O(n^2)$时间复杂度排序算法
| 算法     | 时间复杂度 | 空间复杂度 | 是否稳定排序 |
| -------- | ---------- | ---------- | ------------ |
| 选择排序 | $O(n^2)$   | $O(1)$     | 非稳定排序   |
| 冒泡排序 | $O(n^2)$   | $O(1)$     | 稳定排序     |
| 插入排序 | $O(n^2)$   | $O(1)$     | 稳定排序     |

虽然时间复杂度都是$O(n^2)$但是插入排序往往能减少不必要的比较和交换次数。因此当待排序数据规模n较小时使用插入排序是个很好的选择。

## 选择排序
对于一个长度为n的数组，第一轮选择第一个元素为基数然后从第二个元素开始逐个和基数元素进行比较，如果比基数元素小则进行交换。经过第一轮n-1次比较或交换我们可以找到n个元素内的最小值。然后第二轮选第二个元素作为基数按照相同的方法从基数后面的元素开始逐个进行比较或交换，最终选择到最后一个元素作为基数时排序完成。所需时间复杂度为$(n-1)+(n-2)+....+1=(n^2-n)/2$因此时间复杂度为$O(n^2)$。

假如原始数组为：{4,4,3,5},显然经过第一轮循环后前两个数字4的位置会发生交换。因此选择排序是非稳定排序。由于排序过程未使用额外的空间因此空间复杂度为$O(1)$。

## 冒泡排序
从左至右依次对相邻两个元素进行比较和交换，将较大(或较小的）的元素向一边移动。第一轮两两比较或交换完成后最大(或最小值)出现在数值最右侧，此时数组待排序元素数量变为n-1。后面按照相同的方式在待排序数组上进行多轮操作直至待排序数组长度变为1，此时排序完成。显然时间复杂度也是$O(n^2)$,空间复杂度也一样是$O(1)$。但是由于每次是相邻元素的比较和交换不会改变相同元素的相对位置，因此冒泡排序是一种稳定排序。

冒泡排序优化思路：当待排序数组的后面k次比较都未发生交换时说明后面k+1个元素的顺序已经是有序的了，下次可以只对前面n-k-1个元素进行排序。因此当待排序数组完全有序时可以达到最佳时间复杂度$O(n)$

## 插入排序
对于一个长度为n的数组，首先我们把第一个元素作为已经排序的数组，然后从第二个元素开始逐个和已排序数组的元素进行对比，并将其按照排序规则插入其中。然后按照相同的方式直至将最后一个元素插入到已排序数组中。此时完成排序。外层循环n次，内层插入操作每次需要分别和1、2、3、...、n-1个元素比较。因此整体时间复杂度同样是$O(n^2)$。从左到右插入一次不会改变相同元素的相对位置因此也是一种稳定排序。当原始数组完全有序时同样可以达到最佳时间复杂度$O(n)$。

在一个有序数组中确定待插入位置时大部分情况下并不需要同有序数组中的全部元素进行比较，因此插入排序相比上述排序算法往往能减少不必要的比较和交换次数。插入排序每次处理比较和插入时的操作开销较小因此当待排序数据规模n较小时使用插入排序是个很好的选择。但是当n足够大时$O(n^2)$的时间复杂度可能导致巨大的性能消耗，此时应该采用其他时间复杂度更低的排序算法。

### 插入排序算法java实现（TODO:）
```java

```