---
title: 计算机网络协议篇
date: 2024-11-01 20:30:00 +0800
categories: [网络编程, 计算机网络基础知识]
tags: [networks]     
---

# 网络协议

## 分层理论

![IMG_20241024_130114.jpg](/assets/images/network/IMG_20241024_130114.jpg)

![v2-d9b090fa56b7e6730189a6347d37ee33_1440w.webp](/assets/images/network/v2-d9b090fa56b7e6730189a6347d37ee33_1440w.webp)

## 传输层协议-TCP

### 简介：

TCP（传输层控制协议）是一种面向连接的、可靠的、基于字节流的传输层通讯协议。

| 功能           | 说明                                                                                                                                                           |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 面向连接       | 面向连接意味着通讯双方在数据传输之前需要先建立连接                                                                                                             |
| 可靠传输       | 确保数据按顺序到达，不丢失                                                                                                                                     |
| 流量控制       | 接收方向发送方发送报文时会上报自己**接收缓存**可用空间大小，发送方可根据接收方的是实际情况调整发送频率以避免因为发送方发送数据太快而导致接收方出现接收缓存溢出 |
| 拥塞控制       | TCP会根据网络的拥塞情况来调整发送速率以q确保不会对网络造成太大压力                                                                                             |
| 数据分段与重组 | TCP报文段的大小是有限制的，当来自应用层的数据过大时会拆分成多个报文段进行传输，并在接收方将其进行合并再交给应用层。                                            |

### 服务器TCP连接数限制

服务器所能支撑的TCP连接数受限于两个方面：

1. 文件描述符数量限制
    
    每个TCP连接都需要占用一个文件描述符。因此能够建立的TCP数量首先受限于进程所能打开的文件描述符数量限制。这一限制包括两个等级：
    
    - 系统级别限制：Linux系统整体上限制了所有进程所能打开的最大文件描述符总数，这个限制可以通过 `cat /proc/sys/fs/file-max` 查看并调整。
    - 进程级别限制：单个进程能打开的文件描述符数量受限于`ulimit` 的设置，可以使用 `ulimit -n` 查看并调整。默认情况下，很多系统将此值设置为 1024，但可以根据需要调整，例如：`ulimit -n 100000`这会将当前 shell 中运行的进程的最大文件描述符数量设置为 100000。
2. 内存限制
    
    每个TCP连接都要占用一定的内存。TCP占用内存较大的部分主要是接收缓冲区（默认85KB）和发送缓冲区（默认16KB）。
    
    - 查看当前接收缓冲区大小
        
        ```java
        sysctl net.ipv4.tcp_rmem
        ```
        
        输出通常类似于：
        
        ```java
        net.ipv4.tcp_rmem = 4096 87380 6291456
        ```
        
        这里的三个值分别代表：
        
        - **最小值**：4096字节（4KB），表示TCP接收缓冲区的最小值。
        - **默认值**：87380字节（约85KB），这是TCP连接通常使用的接收缓冲区大小。
        - **最大值**：6291456字节（约6MB），表示TCP接收缓冲区可以根据网络状况增长到的最大值。
    - 查看当前接收缓冲区大小
        
        ```java
        sysctl net.ipv4.tcp_wmem
        ```
        
        输出通常类似于：
        
        ```java
        net.ipv4.tcp_wmem = 4096 16384 4194304
        ```
        
    
    通过上面的描述。默认修改任何系统参数的情况下liunx服务器上一个TCP连接占用内存应为:85KB+16KB+其他用于支持TCP协议所必须的内存占用，即：不少于101KB。  此时若需要支撑百万连接数，则至少会造成96GB的内存消耗。
    
    注意：因为tcp有流量控制，降低服务端缓冲区大小将可能导致客户端降低发送速率。造成用户感知时延增加。另外由于服务端发送缓冲区也变小了，导致应用层通过socket发送数据变慢，也可能会因为无法及时将响应结果传输出去导致积压从而占据更多服务器内存资源。
    

### TCP报文段

为了提高网络传输效率，TCP限制单个报文段数据部分的长度（MSS）。如果应用层通过socket发送的数据量较大（比如传输大文件）TCP可能会将其拆分成多个报文段进行发送，然后在到达侧进行合并再转交给上面的应用层。

![Screenshot_20241024_150538_cn.wps.moffice_eng.png](/assets/images/network/Screenshot_20241024_150538_cn.wps.moffice_eng.png)

### TCP建立连接（三次握手）

1. 客户端（连接建立发起方）发送一个只有首部而不包含数据内容的报文段。该报文段具体内容如下：
    1. 标识位：SYN=1
    2. 序号=客户端随机生成的一个序号（client_isn）
2. 服务端收到来自客户端的上述报文段后向客户端发送SYN&ACK报文，具体如下：
    1. 标识位：SYN=1
    2. 标识位：ACK=1
    3. 序号：服务端随机生成的一个序号(server_isn)
    4. 确认号：接收到的客户端报文段中的序号（client_isn）+1
3. 客户端收到SYN&ACK后发送ACK报文如下：
    1. 标识位：ACK=1
    2. 序号：client_isn+1
    3. 确认号：server_isn+1

![Screenshot_20241024_175532_com.microsoft.emmx.png](/assets/images/network/Screenshot_20241024_175532_com.microsoft.emmx.png)

Q：为什么需要3次握手 

A：

- 站在服务端视角上第一次握手消息到达时（服务端接收到来自客户端的SYN报文段）只是得到了客户端的初始序列号。具体这个握手消息用了多久到达了服务端，客户端该tcp连接请求是否还有效都是未知数。所以服务端只得按照协议向客户端发送SYNACK报文段，如果客户端能正确处理该SYNACK报文段并向服务端发送ACK报文段则才能说明客户端目前还是出在建立连接的过程中且发送的消息能够在有限的时间内到达服务端，同时服务端的消息也能在有限时间内到达客户端。所以此时服务端才会任务建立全双工通信的条件已经具备并标记tcp连状态为ESTABLISHED
- 站在客户端视角上如果客户端成功接收到了SYNACK报文段并且服务端响应的确认号确实是自己本地记录的序号+1，那么说明当前仍然在同一次建立连接的过程中。此时其实对于客户端来说已经可以确认了客户端到服务端、服务端到客户端的消息都能在有限时间内送达。已经具备了建立全双工通信的条件，此时客户端在响应ACK后会立即将TCP连接状态标记为ESTABLISHED
- 综上：三次握手主要对于服务端很重要。比如只进行2次握手的情况下，客户端发出SYN请求后由于网络阻塞等原因导致报文段过了很久才抵达服务端，久到客户端认为建立连接已经失败。此时服务端如果发送SYNACK后将该连接视为已建立并在该链接上等待数据到达将会造成服务器资源的浪费。所以为了整个系统的状态一致需要完成3次握手。

### TCP终止连接（挥手过程）

1. 客户端（终止连接发起方）发送终止报文段（FIN标识=1）后进入状态：FIN_WAIT_1，客户端tcp在此状态下等待来自服务端的ACK确认报文
2. 服务器接收到来自客户端的FIN报文段后立即发送ACK确认，然后进入CLOSE_WAIT状态，服务端在此状态下完成剩余数据的发送
3. 服务端将所有待发送消息发送完毕后发送FIN报文段并进入LAST_ACK状态，等待最后一次来自客户端的ACK
4. 客户端收到来自服务端的FIN报文段后会向服务端发送ACK确认并进入TIME_WAIT状态，此时会等待一段时间（一般是2倍报文生命周期时间）。等待一段时间的目的是防止服务端长时间未接收到来自客户端的最后一次ACK进而重发FIN报文段，如果在TIME_WAIT其间再次收到了服务端的FIN报文段可以再次进行ACK以避免服务端因为接收不到ACK而迟迟不关闭连接，进而造成资源浪费。
5. 服务端收到最后一次ACK后将tcp连接关闭
6. 客户端在TIME_WAIT状态下等待一段时间如果无事发生则关闭TCPL连接

![TCP_挥手.drawio.png](/assets/images/network/TCP_%E6%8C%A5%E6%89%8B.drawio.png)

Q：为什么需要4次挥手

A：断开连接时要保证剩余数据能够发送完毕再关闭，因此被动断开连接方在接收到FIN请求后不能直接发送FIN&ACK而是先ACK然后处理完剩余数据的发送后再单独发送FIN表示己方已经完成所有写入操作

## 传输层协议-UDP

UDP是一种无连接的，面向数据报的传输层通信协议。具有一下特点：

- 无连接：UDB不需要在发送数据前建立连接，而是直接尝试将数据报发送到目标端口
- 数据报的独立性：UDP的数据报是相互独立的（之间没有任何关联），一次发送就是一个完整报文，不像tcp存在拆分和合并。也不保证数据报到达的顺序
- 不保证可靠性：UDP没有确认机制和重传机制也无法保证数据报到达的顺序。所以可能会出现丢包、乱序、重复等情况
- 较少的开销：UDP相对于TCP来说功能简单，开销也较小。适合实时性要求高但是可靠性要求低的场景。

## 应用层协议-HTTP（2.0 VS 1.1）

HTTP/2相对于1.1的一个重大区别在于HTTP/2使用了二进制取代了原来的纯文本协议。HTTP/2将一个完整的请求（或响应）消息拆分成多个二进制帧，多个二进制帧通过相同的流ID来进行关联。HTTP/2以二进制帧为单位进行消息的发送和接收，这样即可实现在同一个tcp连接上并行处理多个请求（连接复用）而且不会遭遇对头阻塞问题。由于消息的不同部分对应这不同类型的二进制帧，因此每种二进制帧都可以根据该类型的特点来定义编码的格式，这样便可实现更紧凑的二进制编码产物，以及更快的解析速度（二进制协议可以约定不同位置代表什么数据，而纯文本协议需要逐字符进行遍历和匹配才能解析出消息不同部分的数据。因此二进制协议拥有更快的解析速度，更少的字节占用）。

| 特性           | **HTTP/1.1**                           | **HTTP/2.0**                        |
| -------------- | -------------------------------------- | ----------------------------------- |
| **连接复用**   | 不支持                                 | 支持，同一连接内可并行多个请求/响应 |
| **数据格式**   | 文本格式                               | 二进制格式                          |
| **首部压缩**   | 不支持，首部信息每次都完整传输         | 支持 HPACK 算法压缩首部             |
| **服务器推送** | 不支持                                 | 支持服务器推送                      |
| **优先级控制** | 无                                     | 支持流的优先级控制                  |
| **队头阻塞**   | 存在严重的队头阻塞问题                 | 通过多路复用解决了队头阻塞问题      |
| **适用场景**   | 适合较为简单的、请求数量较少的应用场景 | 适合现代 Web 应用的大量并行请求     |

注意这里的HTTP2.0的服务端推送指的不是类似Webscoket的全双工网络协议，而是指的服务端在用户未直接请求某个资源（比如index.css）而只请求了index.hml时可以一次性将html和css一块发送给前端，避免浏览器接收到html后再根据html内的include标签再次请求该index.css。不过一般用户不是第一次访问的情况下该css文件可能已经被浏览器缓存到本地了，如果这个时候服务器再进行推送也会造成浪费。所以这个功能目前来还没有完全流行。

## SSL/TLS（传输层和应用层之间）

CA（认证中心）：确定公钥和特定实体的关联关系。并将实体相关数据和该实体的公钥数据一起用CA私钥进行签名并将所有数据封装成证书。用户利用该CA机构公开的公钥验证该证书是否有效。如果通过验证则说明该证书中的公钥确实是该实体所拥有。所以CA机构的权威性很重要，如果一个CA机构不去实际验证实体的真实身份那么该CA机构所颁发的所有证书都将不可信。

SSL/TLS通信的三个阶段：

- 握手
    - 客户端首先向服务端请求建立tcp连接
    - tcp完成3次握手建立连接
    - 客户端向服务端发送hello报文
    - 服务端向客户端发送自己的CA证书
    - 客户端通过该CA证书颁发机构公开的公钥验证服务端返回的证书的有效性
    - 证书验证通过后从证书中获取服务端的公钥
    - 客户端自己创建对称加密主密钥（MS），并利用服务端的公钥进行加密后回传给服务端
    - 服务端通过自己的私钥解密出MS

![Screenshot_20241025_135547_cn.wps.moffice_eng.png](/assets/images/network/Screenshot_20241025_135547_cn.wps.moffice_eng.png)

- 密钥导出
    - 客户端和服务端双方各自根据MS按照相同的算法计算出相关的其他几个密钥（用于消息加密、MAC）
- 数据传输
    - 使用相关密钥进行MAC签名、数据加密后交给底层tcp进行数据传输