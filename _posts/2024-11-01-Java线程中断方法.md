---
title: Java线程中断方法
date: 2024-11-01 20:30:00 +0800
categories: [Java开发, 并发编程]
tags: [java,concurrency]     
---


## Object::wait() VS Condition::await()

Object::wait() 必须与对象的监视器（隐式锁）配合使用。当线程获取某个对象的 monitor 后，可以调用该对象的 wait() 方法，使线程进入 WAITING 状态，同时释放 monitor。

当其他线程在持有同一 monitor 的前提下调用 notify() 或 notifyAll() 时，等待在 WaitSet 中的线程会被移动到 EntryList，并在 monitor 释放后重新竞争锁，竞争成功后才能继续执行。

因此 wait/notify 必须依赖隐式锁，并共享同一个 WaitSet，无法实现多条件拆分。

相比之下，Condition::await() 必须与显式锁（如 ReentrantLock）配套使用，一个锁可以创建多个 Condition，从而将不同等待条件拆分到不同的等待队列中，实现精准唤醒。

例如 ArrayBlockingQueue 内部通过 notEmpty 与 notFull 两个 Condition 来区分 put 与 take 的等待队列：put 只会 signal notEmpty，take 只会 signal notFull。如果使用 Object.wait()，所有等待线程只能放在同一个 WaitSet 中，put 可能误唤醒其他 put 线程，在队列仍满的情况下又继续进入等待，造成大量无效唤醒与上下文切换，降低整体效率。

```java
// ArrayBlockingQueue类部分源码

public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity <= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull =  lock.newCondition();
} 

public void put(E e) throws InterruptedException {
    Objects.requireNonNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await();
        enqueue(e);
    } finally {
        lock.unlock();
    }
}

private void enqueue(E e) {
    final Object[] items = this.items;
    items[putIndex] = e;
    if (++putIndex == items.length) putIndex = 0;
    count++;
    notEmpty.signal();
}

public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0)
            notEmpty.await();
        return dequeue();
    } finally {
        lock.unlock();
    }
}

private E dequeue() {
    final Object[] items = this.items;
    @SuppressWarnings("unchecked")
    E e = (E) items[takeIndex];
    items[takeIndex] = null;
    if (++takeIndex == items.length) takeIndex = 0;
    count--;
    if (itrs != null)
        itrs.elementDequeued();
    notFull.signal();
    return e;
}
```

## Thread::sleep()

调用sleep()方法，线程会进入睡眠（timed waiting）状态。直至到达timeout时间或者线程interrupt。sleep的线程会立即释放cpu时间片，因此有利于其他线程被cpu调度。

> **注意：线程进入睡眠状态时不会释放锁！**

sleep状态下线程interrupt会抛出InterruptedException，需要手动处理该异常。

## LockSupport::park()、LockSupport:parkNanos()、LockSupport:parkUntil()

park()方法可使线程进入waiting状态时。挂起的线程可以通过unpark唤醒。

> **注意：park()方法不会释放锁！**

parkNanos()方法通过参数可以控制线程休眠多长时间，parkUntil()方法则可以控制线程休眠到某一时刻。

> **park() 和 sleep()区别**
> 
>1. 唤醒机制不同
> 
>       sleep 只能超时或 interrupt
> 
>       park 可以 unpark + interrupt + 虚假唤醒 + timeout
>
>2. 中断语义不同
>
>       sleep 被中断会抛 InterruptedException
>
>       park 被中断只是返回，需要手动检查中断标志位
>
>3. 虚假唤醒
>
>       park 存在虚假唤醒
>
>       sleep 不存在虚假唤醒
>
>4. 是否让出 CPU
>
>       sleep 一定让出 CPU
>
>       park 在部分情况下不会让出 CPU（有 permit 时立即返回）

## Object::wait()、Condition::await() 和 LockSupport::park()的虚假唤醒问题

虚假唤醒通常发生在以下情况：

1. **底层系统行为**：操作系统的线程管理和调度算法可能会不时地触发线程唤醒，以确保资源的公平分配。
2. **硬件中断或信号**：硬件中断或操作系统信号可能使线程从等待状态中返回。
3. **JVM 内部优化**：在某些 JVM 的实现中，虚拟机可能会出于性能优化的原因，触发线程的意外唤醒。

### 如何应对虚假唤醒

在实际编程中，为了防止虚假唤醒对程序逻辑的影响，必须用循环检查条件来确保线程只有在满足特定条件时才继续运行。这种应对方法不仅适用于 `park()`，也适用于 `Object.wait()`。

```java

public class ParkExample {
    private static volatile boolean conditionMet = false;

    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            while (!conditionMet) {  // 条件检查
                LockSupport.park();  // 阻塞线程
            }
            System.out.println("Condition met, thread continues...");
        });
        thread.start();

        // 模拟一些操作后满足条件
        try {
            Thread.sleep(1000);  // 等待 1 秒
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        conditionMet = true;  // 条件满足
        LockSupport.unpark(thread);  // 唤醒线程
    }
}

```

在上面的示例中，通过一个 `while` 循环和 `conditionMet` 标志位来确保线程在条件满足前不会退出循环，即使出现虚假唤醒也会再次进入 `park`。只有 `conditionMet` 变为 `true` 后，线程才会跳出循环并继续执行。