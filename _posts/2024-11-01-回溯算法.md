---
title: å›æº¯ç®—æ³•
date: 2024-11-01 18:49:20 +0800
categories: [ç®—æ³•,å›æº¯]
tags: [aogorithm]     
---
# å›æº¯ç®—æ³• 
## ç®—æ³•æ€è·¯
å›æº¯ç®—æ³•æ˜¯ä¸€ç§æ·±åº¦ä¼˜å…ˆéå†ã€‚å‡è®¾ä½ çš„é¢å‰æœ‰nä¸ªé—¨ï¼Œæ¯ä¸ªé—¨åé¢éƒ½æœ‰æ•°é‡ä¸å›ºå®šçš„å¤šä¸ªé—¨ã€‚å·²çŸ¥éƒ¨åˆ†é—¨åé¢è—æœ‰é‡‘çŸ¿çŸ³ï¼Œç°åœ¨è®©ä½ æ‰¾åˆ°æ‰€æœ‰çš„é‡‘çŸ¿å¹¶è®°å½•ä»æœ€åˆå‡ºå‘ä½ç½®åˆ°æ¯ä¸ªé‡‘åº“çš„æœ€çŸ­è·¯å¾„ã€‚åŸåˆ™ä¸Šæˆ‘ä»¬éœ€è¦ä¸åœçš„åšå‡ºé€‰æ‹©æ‰“å¼€ä¸€ä¸ªé—¨ç›´è‡³æœ€åä¸€ä¸ªé—¨ï¼Œç„¶åè¿”å›ä¸Šä¸€ä¸ªé€‰æ‹©çš„åœ°æ–¹é€‰æ‹©å‰©ä¸‹çš„é—¨ï¼Œç›´è‡³å°è¯•è¿‡æ‰€æœ‰çš„é—¨ã€‚å›æº¯ä¸»è¦ä½“ç°åœ¨è¿”å›ä¸Šæ¬¡åšå‡ºé€‰æ‹©çš„åœ°æ–¹é€‰æ‹©ä¸‹ä¸€ä¸ªé—¨å¹¶ä¸”æ’¤é”€ä¸Šä¸€æ¬¡é€‰æ‹©è¿‡ç¨‹çš„è®°å½•ã€‚

## ç®—æ³•æ¡†æ¶
```java
void backtrak(State state,List<Choice> choices,List<State> res){
    //åˆ¤æ–­å½“å‰çŠ¶æ€æ˜¯å¦æ˜¯é—®é¢˜çš„è§£
    if(isSolution(state)){
        //ä¿å­˜å½“å‰è§£
        reocrdSolution(state,res);
        //æ­¤å¤„è¿”å›ä»£è¡¨ä¸ç»§ç»­æ·±å…¥éå†å½“å‰åˆ†æ”¯ï¼Œéœ€è¦ç»§ç»­éå†æ—¶æ­¤å¤„ä¸è¦è¿›è¡Œè¿”å›
        return;
    }

    //éå†å½“å‰çŠ¶æ€ä¸‹ä¸‹ä¸€æ­¥æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©
    for(Choice choice: choices){
        //åšå‡ºé€‰æ‹©ã€è®°å½•çŠ¶æ€æ”¹å˜
        makeChoice(choice,state);
        //åšå‡ºé€‰æ‹©åï¼Œä¸‹ä¸€æ­¥ä»æœ‰å¤šä¸ªé€‰æ‹©æ—¶è¿›è¡Œé€’å½’è°ƒç”¨
        backtrak(state,choices,results);
        //èµ°åˆ°è¿™ä¸€æ­¥è¯´æ˜å½“å‰é€‰æ‹©ä¸‹é—®é¢˜çš„è§£è¦ä¹ˆå·²ç»äº§ç”Ÿè¦ä¹ˆè¿˜æœªäº§ç”Ÿï¼Œç»§ç»­éå†æ—¶éœ€è¦æ’¤é”€å½“å‰åˆ†æ”¯çš„é€‰æ‹©ï¼Œä»æ–°é€‰æ‹©å¼€å§‹è®°å½•çŠ¶æ€
        undoChoice(state,choice);
    }
}
```

## å…¨æ’åˆ—é—®é¢˜
> æ˜¯åœ¨ç»™å®šä¸€ä¸ªé›†åˆï¼ˆå¦‚ä¸€ä¸ªæ•°ç»„ï¼‰çš„æƒ…å†µä¸‹ï¼Œæ‰¾å‡ºå…¶ä¸­å…ƒç´ çš„æ‰€æœ‰å¯èƒ½çš„æ’åˆ—ã€‚
>| è¾“å…¥æ•°ç»„ | æ‰€æœ‰æ’åˆ— |
>|--|--|
>|[1,2]|[1,2],[2,1]|

### æˆ‘ä»¬é¦–å…ˆè€ƒè™‘é›†åˆå†…å…ƒç´ éƒ½ä¸ç›¸åŒçš„æƒ…å†µ
```java
public class AllPermutations {

    public List<List<Integer>> getAllPermutations(int[] array){
        List<Integer> choices = Arrays.stream(array).boxed().collect(Collectors.toList());
        List<Integer> state = new ArrayList<>();
        List<List<Integer>> res = new ArrayList<>();
        backtrack(state,choices,res);
        return res;
    }

    private void backtrack(List<Integer> state, List<Integer> choices, List<List<Integer>> res){
        if (isSolution(state,choices)){
            recordSolution(state,choices,res);
        }

        for (int i = 0; i < choices.size(); i++) {
            if (!state.contains(i)){
                makeChoice(i,state);
                backtrack(state,choices,res);
                undoChoice(state);
            }
        }
    }

    private void undoChoice(List<Integer> state) {
        state.remove(state.size()-1);
    }

    private void makeChoice(int i, List<Integer> state) {
        state.add(i);
    }

    private void recordSolution(List<Integer> state,List<Integer> choices, List<List<Integer>> res) {
        List<Integer> path = new ArrayList<>();
        for (Integer i : state) {
            path.add(choices.get(i));
        }
        res.add(path);
    }

    private boolean isSolution(List<Integer> state,List<Integer> choices) {
        return state.size() == choices.size();
    }

}
```
### è€ƒè™‘é›†åˆå†…å­˜åœ¨ç›¸åŒå…ƒç´ çš„æƒ…å†µ
å‡è®¾é›†åˆå†…å­˜åœ¨ä¸¤ä¸ªaå…ƒç´ ï¼Œé‚£ä¹ˆå½“æ„æˆæ’åˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ å€¼ä¸ºaæ—¶açš„æ¥æºå¯èƒ½æ¥è‡ªä¸¤ä¸ªä¸åŒçš„ä½ç½®ã€‚æˆ‘ä»¬å¯è§‚å¯Ÿåˆ°æ’é™¤ç¬¬ä¸€å…ƒç´ ä¹‹åå‰©ä½™çš„å…ƒç´ ç»„æˆæ˜¯å®Œå…¨ç›¸åŒçš„ï¼ˆéƒ½æ˜¯ä¸€ä¸ªaå’Œå‰©ä½™å…ƒç´ ç»„æˆï¼‰ï¼Œå¯¹åº”çš„æ’åˆ—ç»“æœä¹Ÿç›¸åŒã€‚ç±»ä¼¼çš„å½“æˆ‘ä»¬è¿›è¡Œç¬¬iæ¬¡é€‰æ‹©æ—¶ï¼Œå‰©ä½™å…ƒç´ ä¸­å¦‚æœä¹Ÿæœ‰é‡å¤å€¼çš„æƒ…å†µï¼Œé‚£ä¹ˆå½“ç¬¬1æ¬¡é€‰æ‹©è¿™äº›ä¸åŒçš„é‡å¤å€¼å¯¹åº”çš„æ’åˆ—ä¹Ÿåº”è¯¥æ˜¯ç›¸åŒçš„ã€‚ç»¼ä¸Šæ‰€è¿°æ¯æ¬¡åšé€‰æ‹©æ—¶åªè¦å¯¹å¯é€‰å€¼è¿›è¡Œå»é‡å³å¯ã€‚

åˆ©ç”¨seté›†åˆæ¥è¿›è¡Œå»é‡å¤„ç†ï¼š
```java
private void backtrack(List<Integer> state, List<Integer> choices, List<List<Integer>> res){
        if (isSolution(state,choices)){
            recordSolution(state,choices,res);
        }

        Set<Integer> alreadyChoosed = new HashSet<>();
        for (int i = 0; i < choices.size(); i++) {
            if (!state.contains(i) && !alreadyChoosed.contains(choices.get(i))){
                alreadyChoosed.add(choices.get(i));
                makeChoice(i,state);
                backtrack(state,choices,res);
                undoChoice(state);
            }
        }
    }
```

## å­é›†å’Œé—®é¢˜
> ç»™å®šä¸€ä¸ªæ­£æ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡æ­£æ•´æ•° target ï¼Œè¯·æ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„ç»„åˆï¼Œä½¿å¾—ç»„åˆä¸­çš„å…ƒç´ å’Œç­‰äº target ã€‚ç»™å®šæ•°ç»„æ— é‡å¤å…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ å¯ä»¥è¢«é€‰å–å¤šæ¬¡ã€‚è¯·ä»¥åˆ—è¡¨å½¢å¼è¿”å›è¿™äº›ç»„åˆï¼Œåˆ—è¡¨ä¸­ä¸åº”åŒ…å«é‡å¤ç»„åˆã€‚
>
> ä¾‹å¦‚ï¼Œè¾“å…¥é›†åˆ {3, 4, 5} å’Œç›®æ ‡æ•´æ•° 9 ï¼Œè§£ä¸º {3, 3, 3}, {4, 5} ã€‚éœ€è¦æ³¨æ„ä»¥ä¸‹ä¸¤ç‚¹ã€‚
>- è¾“å…¥é›†åˆä¸­çš„å…ƒç´ å¯ä»¥è¢«æ— é™æ¬¡é‡å¤é€‰å–ã€‚
>- å­é›†ä¸åŒºåˆ†å…ƒç´ é¡ºåºï¼Œæ¯”å¦‚ {4, 5} å’Œ {5, 4} æ˜¯åŒä¸€ä¸ªå­é›†

### å…ˆä¸è€ƒè™‘æ»¡è¶³ç¬¬2ä¸ªæ³¨æ„äº‹é¡¹ï¼Œå³{4, 5} å’Œ {5, 4} éƒ½è®¤ä¸ºæ˜¯è§£ä¹‹ä¸€ã€‚
#### æ€è·¯
å› ä¸ºé›†åˆä¸­çš„å…ƒç´ å¯ä»¥é‡å¤é€‰å–æ‰€ä»¥æ¯æ¬¡å¯é€‰çš„èŒƒå›´éƒ½æ˜¯æ•´ä¸ªè¾“å…¥æ•°ç»„ã€‚isSolutionçš„åˆ¤æ–­ä¾æ®æ˜¯stateä¸­çš„å„ä¸ªå…ƒç´ ä¹‹å’Œç­‰äºtargetã€‚å‰ªæçš„ä¾æ®æ˜¯stateä¸­çš„å…ƒç´ æ·»åŠ æŸä¸ªé€‰æ‹©åçš„sumå€¼ä¸èƒ½å¤§äºtargetã€‚
```java
public class SubSetSum {

    public List<List<Integer>> getSubSet(int[] nums,int target){
        List<Integer> choices = Arrays.stream(nums).boxed().collect(Collectors.toList());
        State state = new State();
        List<List<Integer>> res = new ArrayList<>();
        backtrack(state,choices,res,target);
        return res;
    }

    private void backtrack(State state, List<Integer> choices, List<List<Integer>> res, int target){
        if (isSolution(state,res,target)){
            recordSolution(state,res);
        }

        for (Integer choice : choices) {
            if (isValidChoice(state,choice,target)){
                makeChoice(state,choice);
                backtrack(state,choices,res,target);
                undoChoice(state,choice);
            }
        }
    }

    private void undoChoice(State state, Integer choice) {
        state.setCurSum(state.getCurSum() - choice);
        state.getStatePath().remove(state.getStatePath().size() - 1);
    }

    private void makeChoice(State state, Integer choice) {
        state.setCurSum(state.getCurSum() + choice);
        state.getStatePath().add(choice);
    }

    private boolean isValidChoice(State state, Integer choice, int target) {
        return state.curSum+choice <= target;
    }

    private void recordSolution(State state, List<List<Integer>> res) {
        res.add(new ArrayList<>(state.getStatePath()));
    }

    private boolean isSolution(State state, List<List<Integer>> res, int target) {
        return state.getCurSum() == target;
    }

    private class State{
        private List<Integer> statePath;
        private int curSum;

        public List<Integer> getStatePath() {
            return statePath;
        }

        public void setStatePath(List<Integer> statePath) {
            this.statePath = statePath;
        }

        public int getCurSum() {
            return curSum;
        }

        public void setCurSum(int curSum) {
            this.curSum = curSum;
        }

        public State() {
            this.statePath = new ArrayList<>();
            this.curSum = 0;
        }
    }

}
```

### ç°åœ¨è€ƒè™‘å¦‚ä½•æ»¡è¶³ç¬¬2ä¸ªæ³¨æ„äº‹é¡¹ï¼Œå³{4, 5} å’Œ {5, 4} è§£å»é‡é—®é¢˜ã€‚
#### å»é‡æ€è·¯
1. ç”±äºå¯ä»¥é‡å¤å–å€¼å› æ­¤å¯ä»¥å°†åŸè¾“å…¥æ•°ç»„ä¸­çš„é‡å¤å…ƒç´ æ’é™¤
2. ä¸Šé¢çš„ç®—æ³•å®ç°å¯èƒ½ä¼šå‡ºç°[a,b,c]ã€[a,c,b]ã€[b,a,c]ã€[b,c,a]...è¿™ç§ç±»ä¼¼çš„é‡å¤æƒ…å†µï¼ˆa<=b<=cï¼‰ï¼Œå»é‡çš„è¯æˆ‘ä»¬å¯ä»¥å¼ºè¡Œé€‰æ‹©[a,b,c]ä½œä¸ºæœ€ç»ˆå»é‡çš„ç»“æœï¼Œå¦‚ä½•ä»ä¸Šè¿°6ç§ç»“æœä¸­æ’é™¤å…¶ä»–ç»“æœå‘¢ï¼Ÿå¾ˆæ˜¾ç„¶æˆ‘ä»¬åªéœ€è¦ä¿è¯åé€‰æ‹©çš„å…ƒç´ ä¸å°äºå‰é¢é€‰æ‹©çš„å…ƒç´ å³å¯
#### javaå®ç°
1. å¯¹è¾“å…¥æ•°ç»„è¿›è¡Œæ’åº
2. Stateå¢åŠ ç»´æŠ¤ç°å­˜æœ€å¤§å…ƒç´ å€¼
3. isValidChoiceæ–¹æ³•åˆ¤æ–­å¾…é€‰æ‹©å€¼ä¸å°äºStateä¸­ç°å­˜æœ€å¤§å…ƒç´ å€¼
```java
public class SubSetSum {

    public List<List<Integer>> getSubSet(int[] nums,int target){
        List<Integer> choices = Arrays.stream(nums).boxed().distinct().collect(Collectors.toList());
        State state = new State();
        List<List<Integer>> res = new ArrayList<>();
        backtrack(state,choices,res,target);
        return res;
    }

    private void backtrack(State state, List<Integer> choices, List<List<Integer>> res, int target){
        if (isSolution(state,res,target)){
            recordSolution(state,res);
        }

        for (Integer choice : choices) {
            if (isValidChoice(state,choice,target)){
                makeChoice(state,choice);
                backtrack(state,choices,res,target);
                undoChoice(state,choice);
            }
        }
    }

    private void undoChoice(State state, Integer choice) {
        state.setCurSum(state.getCurSum() - choice);
        state.getStatePath().remove(state.getStatePath().size() - 1);
        if (!state.getStatePath().isEmpty()) {
            state.setMaxVal(state.getStatePath().get(state.getStatePath().size() - 1));
        }else {
            state.setMaxVal(0);
        }
    }

    private void makeChoice(State state, Integer choice) {
        state.setCurSum(state.getCurSum() + choice);
        if (choice > state.getMaxVal()){
            state.setMaxVal(choice);
        }
        state.getStatePath().add(choice);
    }

    private boolean isValidChoice(State state, Integer choice, int target) {
        return state.curSum+choice <= target && choice >= state.getMaxVal();
    }

    private void recordSolution(State state, List<List<Integer>> res) {
        res.add(new ArrayList<>(state.getStatePath()));
    }

    private boolean isSolution(State state, List<List<Integer>> res, int target) {
        return state.getCurSum() == target;
    }

    private class State{
        private List<Integer> statePath;
        private int curSum;
        private int maxVal;

        public List<Integer> getStatePath() {
            return statePath;
        }

        public void setStatePath(List<Integer> statePath) {
            this.statePath = statePath;
        }

        public int getCurSum() {
            return curSum;
        }

        public void setCurSum(int curSum) {
            this.curSum = curSum;
        }

        public int getMaxVal() {
            return maxVal;
        }

        public void setMaxVal(int maxVal) {
            this.maxVal = maxVal;
        }

        public State() {
            this.statePath = new ArrayList<>();
            this.curSum = 0;
            this.maxVal = 0;
        }
    }

}
```

## nçš‡åé—®é¢˜
> æ ¹æ®å›½é™…è±¡æ£‹çš„è§„åˆ™ï¼Œçš‡åå¯ä»¥æ”»å‡»ä¸åŒå¤„ä¸€è¡Œã€ä¸€åˆ—æˆ–ä¸€æ¡æ–œçº¿ä¸Šçš„æ£‹å­ã€‚ç»™å®š ğ‘› ä¸ªçš‡åå’Œä¸€ä¸ª ğ‘› Ã— ğ‘› å¤§å°çš„æ£‹ç›˜ï¼Œå¯»æ‰¾ä½¿å¾—æ‰€æœ‰çš‡åä¹‹é—´æ— æ³•ç›¸äº’æ”»å‡»çš„æ‘†æ”¾æ–¹æ¡ˆã€‚
```java
package com.valley.algorithm.backtrack;

import java.util.ArrayList;
import java.util.List;

/**
 * æ ¹æ®å›½é™…è±¡æ£‹çš„è§„åˆ™ï¼Œçš‡åå¯ä»¥æ”»å‡»ä¸åŒå¤„ä¸€è¡Œã€ä¸€åˆ—æˆ–ä¸€æ¡æ–œçº¿ä¸Šçš„æ£‹å­ã€‚ç»™å®š ğ‘› ä¸ªçš‡å
 * å’Œä¸€ä¸ª ğ‘› Ã— ğ‘› å¤§å°çš„æ£‹ç›˜ï¼Œå¯»æ‰¾ä½¿å¾—æ‰€æœ‰çš‡åä¹‹é—´æ— æ³•ç›¸äº’æ”»å‡»çš„æ‘†æ”¾æ–¹æ¡ˆã€‚
 *
 * @author Dale
 */
public class NQueenV2 {
    private static final String EMPTY_SQUARE = "#";
    private static final String QUEEN_SQUARE = "Q";

    public static void main(String[] args) {
        List<List<List<String>>> results = new NQueenV2().solve(4);
        for (int i = 0; i < results.size(); i++) {
            System.out.println("solution " + i + ":");
            for (List<String> strings : results.get(i)) {
                for (String string : strings) {
                    System.out.print(string + " ");
                }
                System.out.println();
            }
            System.out.println();
        }
    }

    public List<List<List<String>>> solve(int chessboardSize) {
        State state = new State(chessboardSize);
        List<List<List<String>>> res = new ArrayList<>();
        backtrack(0, state, chessboardSize, res);
        return res;
    }

    private void backtrack(int row, State state, int chessboardSize, List<List<List<String>>> res) {
        if (isSolution(row, chessboardSize)) {
            recordSolution(state, res);
            return;
        }

        for (int column = 0; column < chessboardSize; column++) {
            if (isValidChoice(row, column, state, chessboardSize)) {
                state.addQueue(row, column);
                backtrack(row + 1, state, chessboardSize, res);
                state.delQueue(row, column);
            }
        }
    }

    private boolean isValidChoice(int row, int column, State state, int chessboardSize) {
        if (state.getQueenSize() == 0) {
            return true;
        } else if (Boolean.TRUE.equals(state.getHasQueenInColumn().get(column))
                || Boolean.TRUE.equals(state.getHasQueenInDiagonal().get(row - column + chessboardSize - 1))
                || Boolean.TRUE.equals(state.getHasQueenInAntiDiagonal().get(row + column))
        ) {
            return false;
        }
        return true;
    }

    private void recordSolution(State state, List<List<List<String>>> res) {
        List<List<String>> snapshot = state.getSnapshot();
        List<List<String>> solution = new ArrayList<>(snapshot.size());
        for (List<String> rowSnapshot : snapshot) {
            List<String> row = new ArrayList<>(rowSnapshot);
            solution.add(row);
        }
        res.add(solution);
    }

    private boolean isSolution(int row, int chessboardSize) {
        return row == chessboardSize;
    }

    /**
     * æ£‹ç›˜çŠ¶æ€
     */
    private class State {
        /**
         * è®°å½•å½“å‰æ£‹ç›˜çŠ¶æ€å¿«ç…§
         */
        private final List<List<String>> snapshot;
        /**
         * è®°å½•å„ä¸ªåˆ—æ˜¯å¦å­˜åœ¨Queen
         */
        private final List<Boolean> hasQueenInColumn;
        /**
         * è®°å½•å„ä¸ªä¸»å¯¹è§’çº¿ä¸Šæ˜¯å¦å­˜åœ¨Queen
         */
        private final List<Boolean> hasQueenInDiagonal;
        /**
         * è®°å½•å„ä¸ªæ¬¡å¯¹è§’çº¿ä¸Šæ˜¯å¦å­˜åœ¨Queen
         */
        private final List<Boolean> hasQueenInAntiDiagonal;
        /**
         * è®°å½•æ£‹ç›˜ä¸Šqueenæ•°é‡
         */
        private int queenSize = 0;
        private final int chessboardSize;

        public State(int chessboardSize) {
            this.chessboardSize = chessboardSize;
            snapshot = new ArrayList<>(chessboardSize);
            hasQueenInColumn = new ArrayList<>(chessboardSize);
            for (int i = 0; i < chessboardSize; i++) {
                List<String> row = new ArrayList<>(chessboardSize);
                for (int j = 0; j < chessboardSize; j++) {
                    row.add(EMPTY_SQUARE);
                }
                snapshot.add(row);
                hasQueenInColumn.add(Boolean.FALSE);
            }

            int diagonalSize = 2 * chessboardSize - 1;
            hasQueenInDiagonal = new ArrayList<>(diagonalSize);
            hasQueenInAntiDiagonal = new ArrayList<>(diagonalSize);
            for (int i = 0; i < diagonalSize; i++) {
                hasQueenInDiagonal.add(Boolean.FALSE);
                hasQueenInAntiDiagonal.add(Boolean.FALSE);
            }
        }

        public List<List<String>> getSnapshot() {
            return snapshot;
        }

        public List<Boolean> getHasQueenInColumn() {
            return hasQueenInColumn;
        }

        public List<Boolean> getHasQueenInDiagonal() {
            return hasQueenInDiagonal;
        }

        public List<Boolean> getHasQueenInAntiDiagonal() {
            return hasQueenInAntiDiagonal;
        }

        public void addQueue(int row, int column) {
            snapshot.get(row).set(column, QUEEN_SQUARE);
            hasQueenInColumn.set(column, Boolean.TRUE);
            hasQueenInDiagonal.set(row - column + chessboardSize - 1, Boolean.TRUE);
            hasQueenInAntiDiagonal.set(row + column, Boolean.TRUE);
            queenSize++;
        }

        public void delQueue(int row, int column) {
            snapshot.get(row).set(column, EMPTY_SQUARE);
            hasQueenInColumn.set(column, Boolean.FALSE);
            hasQueenInDiagonal.set(row - column + chessboardSize - 1, Boolean.FALSE);
            hasQueenInAntiDiagonal.set(row + column, Boolean.FALSE);
            queenSize--;
        }

        public int getQueenSize() {
            return queenSize;
        }
    }

}
```