---
title: JVM原理和调优
date: 2024-11-01 20:30:00 +0800
categories: [Java开发, Java虚拟机]
tags: [java,concurrency]     
---

## Java运行时内存结构

根据《java虚拟机规范》java虚拟机管理的内存包括以下几个运行时数据区域

- **线程隔离数据区**
    - **程序计数器**：可以理解为线程当前所执行字节码的行号计数器，用来指示线程下一需要执行指令的位置
    - **java虚拟机栈**：在创建线程时同时会分配java虚拟机栈，线程调用方法时会创建新的栈帧用来存储方法运行过程需要的局部变量、操作数栈、动态连接、方法出口等信息。线程中方法的调用和执行完毕伴随着栈帧的入栈和出栈。
    - **本地方法栈**：与java虚拟机栈类似，不过java虚拟机栈用来支持java方法执行，而本地方法栈则服务于native方法调用
- **线程共享数据区**
    - **堆**： 所有的java对象实例和数组都在这里分配
    - **方法区**：用来存储已被java虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等

## 对象存活判断：可达性分析算法

> 这个算法的基本思路就是通过
一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过
程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，
或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
> 

### Java体系中的GCRoot对象

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
- Java虚拟机内部的引用，如**基本数据类型对应的Class对象**，一些**常驻的异常对象**（比如
NullPointExcepiton、OutOfMemoryError）等，还有**系统类加载器**
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

## 强引用、软引用、弱引用、虚引用

| 引用类型                    | 回收时机           | 适用场景                                      | 类                 |
| --------------------------- | ------------------ | --------------------------------------------- | ------------------ |
| 强引用（Strong Reference）  | 从gcroot断开引用   | 普通对象引用                                  |                    |
| 软引用（Soft Reference）    | 内存不足时会被回收 | 缓存（一般不这么干啊，用guava缓存工具不香吗） | `SoftReference`    |
| 弱引用（Weak Reference）    | 下一次 GC 时会回收 | 弱缓存、内存敏感数据                          | `WeakReference`    |
| 虚引用（Phantom Reference） | 永远会被回收       | 跟踪对象生命周期                              | `PhantomReference` |

## 垃圾回收算法&垃圾回收器

### 分代收集理论

> 把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代
（Young Generation）和老年代（Old Generation）两个区域[2]。顾名思义，在新生代中，每次垃圾收集
时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。
> 

部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：

- 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
- 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单
独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
- 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收
集器会有这种行为。
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

### 垃圾回收算法

- 标记-清除算法
    
    当被收集区域经过一次垃圾回收后只有少量对象需要回收时适合使用该算法，这样避免对更大范围内存活对象进行操作。但是此算法会导致产生内存碎片，当每次gc回收的对象越多产生的内存碎片越多。因此此算法可作为分代收集理论中老年代的收集算法。
    
- 标记-复制算法
    
    对待回收区域完成扫描后将存活对象复制到新的区域，原区域整体进行清理以便继续存储数据。当回收区域的对象仅有少量对象存活时应用此算法可以保证较高的效率又能避免产生内存碎片。因此此算法可作为分代收集理论中年轻代上的收集算法。
    
    > HotSpot虚拟机将年轻代又细化为1个eden区和2个survivor区，比例默认为8:1:1。对象首先保存在eden区，当第一次gc时将eden区存活对象应用复制算法拷贝到其中一个survivor区。后续再次gc时将eden区和survivor区的存活对象再复制到两一个survivor区，原survivor区整体清理后空出来以准备进行下一gc。注意此时会有10%的内存空间是被浪费的。
    > 
- 标记-整理算法
    
    相对于标记-清除算法设计不同，整理算法将所有存活的对象向存储空间的一端移动，这样可以避免产生内存碎片适合大对象的内存分配，但是移动操作会带来额外的开销，而且移动操作需要暂停用户应用程序（Stop-the-word）。因此只有少量对象需要回收时才不会对系统造成较大影响。
    

## 垃圾收集器

### 年轻代收集器

- Serial收集器（复制算法）：Serial收集器是一个单线程的收集器，而且在进行垃圾回收时需要暂停所有用户线程。此收集器是所有收集器中额外内存消耗最少的，而且一般客户端模式下运行的java虚拟机管理的内存也不太大，造成的中断一般也在毫秒级别并不会对用户造成太大干扰。因而在jdk7以及之前的版本Serial收集器一直是客户端模式下默认的收集器。
    
    ![image.png](/assets/images/jvm/image.png)
    
- ParNew收集器（复制算法）：Serial收集器的多线程改进版本。除了使用多线程并发收集之外没有别的创新之处。但它却是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作
    
    ![image.png](/assets/images/jvm/image%201.png)
    
    > CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel
    Scavenge配合工作[1]，所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。
    > 
- Parallel Scavenge收集器（复制算法）：吞吐量优先的收集器，其设计目的是为了在整体上降低垃圾回收所占用的cpu事件而不是像cms一样关注用户线程停顿时间。因此Parallel Scanvenge收集器可以用在后台异步处理批量任务的服务上，比如消息队列消费者服务。
    
    > Parallel Scavenge收集器相关参数介绍：
    > 
    - 控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数
    - 直接设置吞吐量大小的-XX：GCTimeRatio参数。
    - **自适应的调节策略**参数-XX：+UseAdaptiveSizePolicy当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区
    的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

### 老年代收集器

- Serial Old收集器（整理算法）：Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。其存在意义也是在单线程客户端环境下使用。
- Parallel Old收集器（整理算法）：Parallel Old是Parallel Scavenge收集器的老年代版本。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。
- CMS收集器（清除+整理算法）：是一种以获取最短回收停顿时间为目标的收集器。
    
    CMS垃圾回收四个阶段：
    
    - 初始标记：仅标记GCRoots能直接关联到的对象，会造成停顿但是由于涉及的对象数量少因而停顿时间很短
    - 并发标记：从这些直接关联的对象开始并发遍历对象图，这个过程不需要停顿而是和用户线程一起并发执行，但是耗时较长
    - 重新标记：这一阶段主要标记那些初始标记后变动的部分，需要停顿但是由于涉及的对象数量少因而停顿时间也很短
    - 并发清除：对所有已经不再存活的对象进行清除，由于不涉及移动或复制操作因而也无需停顿。
    
    CMS触发内存整理（默认配置下每次fullgc都会触发内存整理）：
    
    - XX：+UseCMS-CompactAtFullCollection开关参数（默认是开启的，此参数从JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长
    - XX：CMSFullGCsBeforeCompaction（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）
    
    ![image.png](/assets/images/jvm/image%202.png)
    
    注意事项：
    
    1. CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大
    2. 由于CMS收集器无法处理“浮动垃圾”（重新标记后产生的垃圾将不会被并发清除），而且并发清除过程还需要让用户线程有足够的资源运行因此不能等老年代内存剩余空间太少的时候再执行回收。在JDK5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数-XX：CMSInitiatingOccu-pancyFraction的值。在JDK6中这一参数默认值为92%，但是过高的阈值可能导致在cms回收期间出现剩余空间不足无法分配内存的情况，一旦发生这种情况java虚拟机将退回到使用serial Old来重新进行老年代的回收操作

### 跨代收集器

- G1收集器（在延迟可控的情况下获得尽可能高的吞吐量）

可以由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置最长的期望停顿
时间（指定 `-XX:MaxGCPauseMillis`），可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。它默认的停顿目标为两百毫秒。

G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现

G1收集器的前辈们垃圾回收的对象要么是整个新生代要么是整个老年代甚至还有整个堆。而G1收集器可以面向堆内的任何一部分来组成回收集进行回收。从而能够实现优先对预期回收收益大的区域进行回收。

G1收集器**将连续的Java堆划分为多个大小相等的独立区域（Region）**，**每一个Region都可以
根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间**。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个
Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数`-XX：G1HeapRegionSize`设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让**G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，**每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来

**为了避免对某个region回收时需要在整个堆上检查是有有到该region内对象的引用关系，每个Region需要记录引用和被其他region引用的双向卡表信息，因此使用G1收集器将导致额外10%-20%的堆上内存占用以用来支持垃圾回收。**

G1收集器垃圾回收的四个阶段：

- 初始标记，和cms一样标记处和GcRoots直接关联的对象，需要停顿但停顿时间可控
- 并发标记，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆
里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
- 最终标记，对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留
下来的最后那少量的SATB记录。
- 筛选回收，负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，**然后把决定回收的那一部分Region的存活对象复制到空的Region中**，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，
换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐
量

![image.png](/assets/images/jvm/image%203.png)

> 到了JDK 8 Update 40（最后一个可以免费使用的oracle jdk版本是8 update 202）的时候，G1提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”（Fully-Featured Garbage Collector）
> 

G1整体上是基于标记-整理，局部上采用标记-复制如何理解？

> 筛选回收阶段：region内存活的对象会被复制到其他空的region中这个步骤本身是复制算法。我的理解应该这里是选择的连续的空region，即选择空region的策略实现了整理的功能。将存活对象都复制到相对连续的region中了。
> 

G1和CMS对比

- CMS关注最短停顿时间，适用于直接面向用户需要快速响应的服务。但是可能会产生内存碎片进而造成fulGc。运行起来就是大部分时间gc表现很好但是偶尔会触发fulgc。通过技术手段在闲暇时定时触发fulgc或重启不就行了？
- G1则能在指定最长停顿时间的前提下以吞吐量更高的。能够支持业务长时间稳定运行但是消耗资源较高。建议在大堆（6-8g以上）上使用g1。g1相对来说在服务器资源充足的情况下是比较均衡的一个收集器。

### 各版本JDK默认收集器

> JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器
> 

## 消失的永久代

> JDK8以前java使用永久代来实现方法区，其目的是为了避免单独为方法区开发垃圾回收代码。但是这样做的副作用是使得方法区更容易内存溢出。因为永久代有有`-XX：MaxPermSize`的上限，即使不设置也有默认大小。而且方法区的数据需要回收的情况较少，和堆内存一块回收会拖慢垃圾收集器的执行效率。
> 

> 到了JDK7的hotspot时已经将字符串常量池和静态变量从永久代中移除。到了JDK8时则完全废弃了永久代概念。将之前永久代中存储的数据全部转移到本地内存实现的元空间（Metaspace）中。元空间可以自动扩展或配置上限，可以通过 JVM 参数 `-XX:MaxMetaspaceSize` 设置上限；如果未设置该参数，元空间会一直增长，直到达到系统内存的上限或达到系统进程限制（**32 位系统**：单个进程的可用地址空间通常为 4 GB，**64 位系统**：64 位系统的地址空间极大（理论上达到 16 EB，远超物理内存的实际容量））。
> 

> 上面提到的**本地内存** 指的是 JVM 从操作系统直接申请的内存区域，不受堆内存（Heap）大小设置的限制
> 

## 常用JVM参数

- 直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不
去指定，则默认与Java堆最大值（由-Xmx指定）一致
- **-Xms<size>**：设置 JVM 启动时的初始堆内存大小。例如，`Xms512m` 表示初始堆大小为 512MB。
- **-Xmx<size>**：设置 JVM 最大堆内存大小。例如，`Xmx4g` 表示最大堆大小为 4GB。
- `-Xmn<size>`：用于设置年轻代的大小。例如，`-Xmn512m` 将年轻代大小设置为 512MB。
- 可以通过设置 `-XX:NewRatio=<ratio>` 来指定年轻代与老年代的比例。例如，`-XX:NewRatio=3` 表示年轻代占用老年代的 1/3。
- **-Xss<size>**：设置每个线程的栈大小。例如，`Xss1m` 表示每个线程的栈大小为 1MB。
- **-XX=<size>**：设置 Metaspace 的初始大小，控制类元数据的内存使用。可以使用类似 `-XX:MetaspaceSize=128m` 的格式。
- **-XX=<size>**：设置 Metaspace 的最大大小，防止内存耗尽。可以使用类似 `-XX:MaxMetaspaceSize=512m` 的格式。

## JVM优化思路

1. 首先业务类型和资源情况选择垃圾收集器
    1. 如果是面向用户直接提供服务的应用则应该注重低延迟，可以使用parNew+cms。
    2. 如果是用于异步处理任务的服务，对延迟不敏感的应该使用吞吐量有限的垃圾收集器：parellel scavenge+parellel old
    3. 如果是需要大内存的应用且服务器内存充足，可以使用G1，合理设置最长停顿时间来限制最长停顿耗时并保持高吞吐率
2. 根据业务情况选择是否启动HeapDumpOnOutOfMemoryError。如果业务需要尽快恢复建议且没有运维机制确保发生outofMemory后能服务能自动下线并启动新节点，则此时应该触发服务重启而不是打印堆栈。应该通过监控手段在发生outofMemory之前发出预警，并提前接入手动通过jmap保存堆栈数据
3. 跟踪记录jvm运行数据，合理调整配置参数
    1. 如果观察到数据主要分布在eden区和老年代（比如文件处理服务这种可能单个对象都挺大的），说明survivor空间设置较小无法发挥作用应适当增多survivor空间占比（默认survivor占年轻代的1/10）以避免minorgc导致对象直接进入老年代
    2. 年轻代垃圾回收成本较低，当服务器内存资源受限且大部分对象生命周期不长的情况下可以考虑适当增大年轻代大小（年轻代默认占整个堆的1/3）
    3. 当内存增长较快时且使用cms收集器情况下可以适当降低老年代垃圾回收阈值（默认68%）。如果降低阈值后导致老年代gc特别频繁则只有加大内存了。
    4. 上面总体思路就是压力来了之后尽量让年轻代去消化。年轻代消话不了的话再进老年代。这个思路成立的一个前提是大部分对象确实生命周期很短，如果大部分对象确实生命周期较长还是尽快进入老年代比较合适。

## JVM监控工具&优化工具

打印线程栈：jstack

打印堆快照：jmap

查询java程序pid：jps或者ps

在线jstack分析网站：fastThread.io

堆快照分析工具：eclipse mat

top命令下查出具体线程：

1. 通过top找到java进程
2. 使用命令：`top -H -p <PID>` 来显示指定pid下的线程
3. 上述top-H命令获得的线程id（字段名也是PID）是十进制的，而jstakc里的线程id时16进制，需要转换后在jstack文件中搜索