---
title: MySQL锁机制
date: 2021-12-17 14:49:20 +0800
categories: [数据库, MySQL]
tags: [mysql]     
---

| 锁级别             | 是否支持共享锁                   | 是否支持排它锁                     | 是否支持意向锁 | 描述                                                                      |
| ------------------ | -------------------------------- | ---------------------------------- | -------------- | ------------------------------------------------------------------------- |
| 全局锁             | N                                | 全局锁为排它锁                     | N              | 语句：FLUSH TABLES WITH READ LOCK，使得所有表进入只读模式。可用于数据备份 |
| 表级锁             | Y（LOCK TABLES table_name READ;) | Y (LOCK TABLES table_name WRITE; ) | N              | 表级锁用来做什么？innodb支持表级锁吗                                      |
| 元数据锁（表级别） |                                  |                                    |                |                                                                           |
| 行级锁             | Y                                | Y                                  | Y              | mysql InnoDB存储引擎支持行级锁                                            |


意向锁 只存在于 InnoDB 的行级锁，用于配合行锁和表锁，快速判断锁冲突。
- 如果事务对某一行加了共享锁，那么会在表上加一个IS 锁。
- 如果事务对某一行加了排他锁，那么会在表上加一个IX 锁。

意向锁的特点
自动加锁：意向锁是 InnoDB 自动加上的，用户不需要手动管理。
例如，当事务对表中的某行加 S 锁或 X 锁时，InnoDB 会自动在表级别加上 IS 锁或 IX 锁。

不影响行锁：意向锁是表级锁，但不会阻塞其他事务的行锁操作（加具体行的 S 锁或 X 锁）。
提高加锁效率：

意向锁的存在避免了表级锁与行级锁之间的冲突检查，提升了加锁的效率。
例如，当事务需要对表加X锁时需要确保表中的所有数据行不能被添加了S锁或者X锁。由于Mysql对某一行添加锁时会在表上添加意向锁，所以通过检查表上的意向锁即可知道表内是否有某些数据行处于锁定状态。

意向锁本身不会与行锁冲突，它与表级锁之间的冲突规则如下：

| 锁类型           | 意向共享锁（IS） | 意向排他锁（IX） | 共享锁（S） | 排他锁（X） |
| :--------------- | :--------------- | :--------------- | :---------- | :---------- |
| 意向共享锁（IS） | 兼容             | 兼容             | 兼容        | 冲突        |
| 意向排他锁（IX） | 兼容             | 兼容             | 冲突        | 冲突        |
| 共享锁（S）      | 兼容             | 冲突             | 兼容        | 冲突        |
| 排他锁（X）      | 冲突             | 冲突             | 冲突        | 冲突        |


MySQL行级锁包括：record lock、gap lock 、next-key lock


## MySQL常见死锁原因
1. 不同事务对资源加锁顺序不一致
2. RR级别下范围锁与行锁冲突
   前置知识点：意向锁
   插入意向锁是一种特殊的 Gap 锁（间隙锁）。
当事务向表中插入一条记录时，InnoDB 不会立即对该记录或范围加锁，而是标记为 意向锁，表示事务 准备插入 这条记录。
这种锁的作用是 避免与其他事务的范围锁或间隙锁发生冲突而不会和其他插入意向锁之间形成冲突。
    GAP锁+插入意向锁情况下的死锁：
        两个事务同时获取相同区间的gap锁，然后分别向该区间内插入数据。插入数据时需要获取插入意向锁，由于插入意向锁和gap锁之间会冲突所以造成了互相等待的死锁情况。

    
## MySQL如何检测和处理死锁
死锁检测机制：
MySQL 会自动检测死锁并中止其中一个事务，报出 Deadlock Found 错误，释放其持有的锁，使其他事务能够继续执行。

如何处理死锁：

通过设置 innodb_lock_wait_timeout 参数，控制事务等待锁的最长时间。
合理设计事务逻辑，避免多个事务同时竞争同一资源。