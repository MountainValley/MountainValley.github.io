---
title: 单例模式
date: 2024-11-01 18:49:20 +0800
categories: [Java开发,设计模式]
tags: [design mode]     
---

## 简介

单例模式（Singleton Pattern）是创建型设计模式的一种，用于确保一个类在整个应用程序中只有一个实例，并提供全局访问点。

根据实现方式的不同，单例模式可以分为多种类型，每种类型的优缺点和适用场景如下：

### 饿汉式（Eager Initialization）

在类加载时就创建单例实例，实例为类的静态成员变量。

```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

### 懒汉式（Lazy Initialization）

在需要时才创建实例。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 线程安全的懒汉式-基于双重检查锁实现（Double-Checked Locking）

通过双重检查、锁机制和volatile关键字确保线程安全，同时减少锁的开销。

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 静态内部类

利用静态内部类实现延迟加载，同时保证线程安全。

```java
public class Singleton {
    private Singleton() {}

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

### 枚举单例

使用枚举类来实现单例。

```java
public enum Singleton {
    INSTANCE;

    public void someMethod() {
        System.out.println("Do something");
    }
}
```

对比总结

| 类型           | 是否线程安全 | 是否延迟加载 | 优点                                                                       | 缺点                         | 适用场景                       |
| -------------- | ------------ | ------------ | -------------------------------------------------------------------------- | ---------------------------- | ------------------------------ |
| 饿汉式         | 是           | 否           | 简单，线程安全                                                             | 类加载即初始化，可能浪费资源 | 实例需要即刻加载的小对象       |
| 懒汉式         | 否           | 是           | 延迟加载，节省资源                                                         | 多线程环境不安全             | 单线程环境或线程安全可控场景   |
| 线程安全懒汉式 | 是           | 是           | 线程安全                                                                   | 性能较低，每次获取实例都加锁 | 多线程环境，对性能要求不高     |
| 双重检查锁     | 是           | 是           | 线程安全，高效                                                             | 实现复杂，需要 volatile 支持 | 多线程环境，高性能要求         |
| 静态内部类     | 是           | 是           | 延迟加载，线程安全，无需显式加锁                                           | 类结构较复杂                 | 希望性能和延迟加载的平衡场景   |
| 枚举单例       | 是           | 否           | 简单，线程安全，防止反序列化破坏单例（JVM 保证枚举单例的唯一性）和反射攻击 | 不支持延迟加载               | 防止序列化破坏，高安全要求场景 |

### 最佳实践建议
- 延迟加载、高性能、线程安全：推荐使用**静态内部类**或**双重检查锁**。
- 程序运行一定会用到的或者实例化耗时较长的可以使用饿汉式在服务器启动时类加载的过程中既完成单例创建
- 在需要强安全的单例时使用枚举单例。因为枚举单例无法通过反射创建实例（抛出异常），且jvm保证枚举实例反序列化后的对象为原单例对象。

